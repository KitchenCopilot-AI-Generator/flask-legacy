Directory Structure:
===================

README.md
assets
├── ImageUpload.png
├── Ingredients.png
└── Recipes.png
backend
├── api
    └── routes.py
├── config.py
├── container
    ├── fridge_1743074276_5115e30c
        ├── image_1743074276_5115e30c.jpg
        ├── ingredients_1743074276_5115e30c.json
        └── recipes_1743074276_5115e30c.json
    ├── fridge_1743074341_95b1da55
        ├── image_1743074341_95b1da55.jpg
        ├── ingredients_1743074341_95b1da55.json
        └── recipes_1743074341_95b1da55.json
    └── fridge_1743083508_8c784f9f
├── main.py
├── models
    ├── ingredients.py
    └── recipes.py
├── prompts
    ├── recipe_prompt.py
    └── vision_prompt.py
├── services
    ├── azure_client.py
    ├── recipe_service.py
    └── vision_service.py
└── utils
    └── image_utils.py
kitchen-copilot-frontend
requirements.txt
sample-images

File Contents:
=============

--- README.md ---
# Kitchen Copilot

An application that analyses your refrigerator contents through images and suggests recipes based on available ingredients.

![Kitchen Copilot Image Upload Interface](assets/ImageUpload.png)


## Features
- **Image Analysis**: Upload a photo of your fridge or food items to identify ingredients
- **Recipe Generation**: Get customized recipe suggestions based on identified ingredients
- **Dual Operation Modes**: Run as a CLI tool or as an API backend
- **Modern Frontend**: Interactive web interface for easy ingredient analysis and recipe browsing

## Requirements
- Python 3.8+
- Azure OpenAI API access with a deployed GPT-4 Vision model
- Node.js 18+ (for frontend)

## Setup

### Backend Setup
1. Clone the repository
2. Navigate to the project root
3. Install Python dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Copy the `.env.example` file to `.env` and add your Azure OpenAI API keys and settings
5. Install CORS support for the API:
   ```bash
   pip install flask-cors
   ```

### Frontend Setup
1. Navigate to the frontend directory:
   ```bash
   cd kitchen-copilot-frontend
   ```
2. Install dependencies:
   ```bash
   npm install
   ```
3. Create a `.env.local` file with:
   ```
   NEXT_PUBLIC_API_URL=http://localhost:5000
   ```

## Usage

### Running the Full Application
1. Navigate to the backend directory:
   ```bash
   cd backend

2. Start the backend API server:
   ```bash
   python main.py --host 0.0.0.0 --port 5000
   ```

3. In a separate terminal, start the frontend development server:
   ```bash
   cd kitchen-copilot-frontend
   npm run dev
   ```

3. Open [http://localhost:3000](http://localhost:3000) in your browser to access the application

#### API Endpoints
- `POST /analyze-image`: Upload and analyze a fridge image
- `GET /ingredients`: Get ingredients from the most recent analysis
- `POST /generate-recipes`: Generate recipe suggestions based on available ingredients
- `GET /recipes`: Get previously generated recipes

## Demo Mode

For development and testing purposes, you can visit [http://localhost:3000/demo](http://localhost:3000/demo) to see the frontend with pre-filled sample data, without needing to connect to the backend API.

## Using Postman with the API

You can easily test the API endpoints using Postman. Here's how to make requests to each endpoint:

### 1. Analyze Image Endpoint (POST /analyze-image)

1. Open Postman and create a new POST request to `http://localhost:5000/analyze-image`
2. In the request builder, select the "Body" tab
3. Select "form-data"
4. Add a key named "file" and change the type from "Text" to "File"
5. Click "Select Files" and choose an image of your refrigerator
6. Click "Send" to submit the request

Example response:
```json
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": ["milk", "cheddar cheese", "yogurt"],
      "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
      "Proteins": ["chicken breast", "eggs"],
      "Condiments": ["ketchup", "mayonnaise", "mustard"]
    }
  },
  "summary": {
    "total_count": 10,
    "categories": 4,
    "by_category": {
      "Dairy": 3,
      "Produce": 4,
      "Proteins": 2,
      "Condiments": 3
    }
  },
  "image_filename": "image_1743074276_5115e30c.jpg",
  "request_id": "fridge_1743074276_5115e30c"
}
```

### 2. Get Ingredients Endpoint (GET /ingredients)

1. Create a new GET request to `http://localhost:5000/ingredients`
2. Optionally, you can add a query parameter named "request_id" if you want to get ingredients from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Ingredients Analysis Display](assets/Ingredients.png)

Example response:
```json
{
  "ingredients": {
    "Dairy": ["milk", "cheddar cheese", "yogurt"],
    "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
    "Proteins": ["chicken breast", "eggs"],
    "Condiments": ["ketchup", "mayonnaise", "mustard"]
  }
}
```

### 3. Get Recipes Endpoint (GET /recipes)

1. Create a new GET request to `http://localhost:5000/recipes`
2. Optionally, you can add a query parameter named "request_id" if you want to get recipes from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Recipe Suggestions Display](assets/Recipes.png)

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

### 4. Generate Recipes Endpoint (POST /generate-recipes)

1. Create a new POST request to `http://localhost:5000/generate-recipes`
2. In the request builder, select the "Body" tab
3. Select "raw" and choose "JSON" from the dropdown
4. Enter the request body:
   ```json
   {
     "num_recipes": 5,
     "request_id": "fridge_1743074276_5115e30c"
   }
   ```
   - Replace "fridge_1743074276_5115e30c" with the actual request_id from your analyze-image response
   - You can omit the request_id to use the most recent analysis
5. Click "Send" to submit the request

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

## Project Structure
```
kitchen-copilot/
├── .env                                                  # Environment variables
├── backend/                                              # Backend directory
│   ├── main.py                                           # Main entry point
│   ├── config.py                                         # Configuration and environment loading
│   ├── utils/                                            # Utility functions
│   ├── services/                                         # Core services
│   └── models/                                           # Data models
├── container/                                            # Container data
│   └── fridge/                                           # Fridge data
│       ├── fridge_1743074276_5115e30c/                   # Specific fridge instance
│           ├── image_1743074276_5115e30c.jpg
│           ├── ingredients_1743074276_5115e30c.json
│           └── recipes_1743074276_5115e30c.json
├── api/                                                  # API endpoints
└── kitchen-copilot-frontend/                             # Next.js frontend application
    ├── src/                                              # Frontend source code
    │   ├── app/                                          # Next.js app router pages
    │   ├── components/                                   # React components
    │   ├── lib/                                          # Utility functions and API client
    │   └── types/                                        # TypeScript type definitions
    ├── public/                                           # Static assets
    └── package.json                                      # Frontend dependencies
```

## Troubleshooting

### CORS Issues
If you encounter CORS errors when the frontend tries to communicate with the backend:

1. Make sure you've installed flask-cors:
   ```bash
   pip install flask-cors
   ```

2. Ensure your main.py includes:
   ```python
   from flask import Flask
   from flask_cors import CORS

   app = Flask(__name__)
   CORS(app)
   ```

### API Connection Issues
- Verify that the backend API is running on the correct host and port
- Check that `NEXT_PUBLIC_API_URL` in the frontend's `.env.local` matches the backend URL
- Try accessing the API directly in the browser (e.g., http://localhost:5000/ingredients)


--- assets/ImageUpload.png ---
[Binary file]

--- assets/Ingredients.png ---
[Binary file]

--- assets/Recipes.png ---
[Binary file]

--- backend/api/routes.py ---
"""
API Routes - Flask routes for the Kitchen Copilot application

This module preserves the exact API interface expected by the frontend,
while using Flask instead of FastAPI for implementation.
"""

import os
import json
import glob
from flask import Blueprint, request, jsonify

# Create a Blueprint instead of a Flask app
app = Blueprint('api', __name__)

# Store references to services initialized in main.py
vision_service = None
recipe_service = None
config = None

@app.route('/analyze-image', methods=['POST'])
def analyze_image():
    """
    Analyze a fridge/food image and identify ingredients
    
    Returns:
        Analysis result or processing status
    """
    try:
        # Check if file was uploaded
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
            
        # Get file paths with the new naming convention
        paths = config.get_file_paths(file.filename)
        
        # Save the uploaded file directly to the results directory
        os.makedirs(os.path.dirname(paths["request_image"]), exist_ok=True)
        file.save(paths["request_image"])
        
        # Process synchronously
        result = vision_service.analyze_image(paths["request_image"])
        vision_service.save_analysis(result, paths["vision_output"])
        
        # Get a summary
        summary = vision_service.get_ingredients_summary(result)
        
        # Include request_id (which is the folder name)
        request_id = paths["request_id"]
        # Get just the filename, not the full path
        image_filename = os.path.basename(paths["request_image"])
        
        return jsonify({
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename,
            "request_id": request_id
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/ingredients', methods=['GET'])
def get_ingredients():
    """
    Get ingredients for the specified request ID
    
    Returns:
        Ingredients data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if not request_id:
            return jsonify({
                "error": "Missing required parameter: request_id. Please specify a request_id to retrieve ingredients."
            }), 400
        
        try:
            # Get paths using the request_id
            paths = config.get_file_paths(request_id=request_id)
            ingredients_file = paths["vision_output"]
        except ValueError as e:
            return jsonify({"error": str(e)}), 404
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": f"No ingredients file found for request_id: {request_id}"
            }), 404
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    """
    Get recipes for the specified request ID
    
    Returns:
        Recipes data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if not request_id:
            return jsonify({
                "error": "Missing required parameter: request_id. Please specify a request_id to retrieve recipes."
            }), 400
        
        try:
            # Get paths using the request_id
            paths = config.get_file_paths(request_id=request_id)
            recipes_file = paths["recipes_output"]
        except ValueError as e:
            return jsonify({"error": str(e)}), 404
        
        # Check if file exists
        if not os.path.exists(recipes_file):
            return jsonify({
                "error": f"No recipes file found for request_id: {request_id}"
            }), 404
        
        # Load and return the recipes
        with open(recipes_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/generate-recipes', methods=['POST'])
def generate_recipes():
    """
    Generate recipe suggestions based on available ingredients for the specified request ID
    
    Returns:
        Generated recipes
    """
    try:
        # Parse request data
        data = request.get_json() or {}
        num_recipes = data.get('num_recipes', 5)
        request_id = data.get('request_id')
        
        if not request_id:
            return jsonify({
                "error": "Missing required parameter: request_id. Please specify a request_id to generate recipes."
            }), 400
        
        try:
            # Get paths using the request_id
            paths = config.get_file_paths(request_id=request_id)
            ingredients_file = paths["vision_output"]
            recipes_output = paths["recipes_output"]
        except ValueError as e:
            return jsonify({"error": str(e)}), 404
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": f"No ingredients file found for request_id: {request_id}"
            }), 404
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=num_recipes
        )
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        # Create full response
        full_response = {
            "items": recipes_data["recipes"],
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
        
        # Save the full response
        os.makedirs(os.path.dirname(recipes_output), exist_ok=True)
        with open(recipes_output, "w") as f:
            json.dump(full_response, f, indent=2)
        
        return jsonify(full_response)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

--- backend/config.py ---
"""
Configuration module - Handles environment variables and configuration
"""

import os
import time
from dotenv import load_dotenv

class Config:
    """Configuration class that loads and provides access to environment variables"""
    
    def __init__(self):
        """Initialize configuration by loading environment variables"""
        load_dotenv()
        self.azure_openai_api_key = os.getenv("AZURE_OPENAI_API_KEY")
        self.azure_openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        self.api_version = os.getenv("API_VERSION")
        self.model_name = os.getenv("MODEL_NAME")
        
        # Default paths
        self.results_dir = os.getenv("RESULTS_DIR", "./container")
        
        # Ensure directories exist
        os.makedirs(self.results_dir, exist_ok=True)
    
    def get_azure_config(self):
        """Get Azure OpenAI configuration as a dictionary"""
        return {
            "api_key": self.azure_openai_api_key,
            "api_version": self.api_version,
            "endpoint": self.azure_openai_endpoint,
            "model_name": self.model_name
        }
    
    def get_file_paths(self, image_filename=None, request_id=None):
        """
        Get file paths for input and output files
        
        Args:
            image_filename: Optional image filename to create request-specific paths
            request_id: Optional request ID to retrieve existing paths
            
        Returns:
            Dictionary with paths for input and output files
            
        Raises:
            ValueError: If neither image_filename nor request_id is provided
        """
        if image_filename:
            # Create a timestamp and unique ID for file naming
            timestamp = int(time.time())
            
            # Extract the unique part of the uploaded image filename or generate a new one
            if '_' in image_filename:
                unique_id = image_filename.split('_')[-1].split('.')[0]
            else:
                unique_id = os.urandom(4).hex()
                
            # Create a timestamp-based folder name
            folder_name = f"fridge_{timestamp}_{unique_id}"
            
            # Create request-specific result directory
            request_dir = os.path.join(self.results_dir, folder_name)
            os.makedirs(request_dir, exist_ok=True)
            
            # Create file names with timestamp and unique ID
            image_name = f"image_{timestamp}_{unique_id}{os.path.splitext(image_filename)[1]}"
            ingredients_name = f"ingredients_{timestamp}_{unique_id}.json"
            recipes_name = f"recipes_{timestamp}_{unique_id}.json"
            
            paths = {
                "request_dir": request_dir,
                "vision_output": os.path.join(request_dir, ingredients_name),
                "recipes_output": os.path.join(request_dir, recipes_name),
                "request_image": os.path.join(request_dir, image_name),
                "request_id": folder_name
            }
        elif request_id:
            # Use the provided request_id to locate files
            request_dir = os.path.join(self.results_dir, request_id)
            
            if not os.path.exists(request_dir):
                raise ValueError(f"Request directory not found for request_id: {request_id}")
                
            # Find corresponding files in the directory
            dir_files = os.listdir(request_dir)
            image_files = [f for f in dir_files if f.startswith("image_")]
            ingredients_files = [f for f in dir_files if f.startswith("ingredients_")]
            recipes_files = [f for f in dir_files if f.startswith("recipes_")]
            
            # Use the files if they exist, otherwise construct expected filenames
            # Extract timestamp_unique_id part from request_id (after "fridge_")
            id_part = request_id.split('_', 1)[1] if '_' in request_id else request_id
            
            image_file = image_files[0] if image_files else f"image_{id_part}.jpg"
            ingredients_file = ingredients_files[0] if ingredients_files else f"ingredients_{id_part}.json"
            recipes_file = recipes_files[0] if recipes_files else f"recipes_{id_part}.json"
            
            paths = {
                "request_dir": request_dir,
                "vision_output": os.path.join(request_dir, ingredients_file),
                "recipes_output": os.path.join(request_dir, recipes_file),
                "request_image": os.path.join(request_dir, image_file),
                "request_id": request_id
            }
        else:
            # No filename or request_id provided - this is an error case
            raise ValueError("Either image_filename or request_id must be provided to get file paths")
                
        return paths

--- backend/container/fridge_1743074276_5115e30c/image_1743074276_5115e30c.jpg ---
[Binary file]

--- backend/container/fridge_1743074276_5115e30c/ingredients_1743074276_5115e30c.json ---
{
  "ingredients": {
    "Dairy": [
      "Philadelphia cream cheese",
      "Land O Lakes butter"
    ],
    "Produce": [
      "Bananas",
      "Pears",
      "Apples",
      "Lemons",
      "Oranges",
      "Mixed bell peppers",
      "Fresh spinach leaves",
      "Fresh cilantro",
      "Fresh mint",
      "Red cabbage",
      "Carrots"
    ],
    "Proteins": [],
    "Grains": [
      "Tortillas"
    ],
    "Condiments": [
      "Heinz tomato ketchup",
      "Maple Grove Farms maple syrup",
      "Annie's yellow mustard",
      "Hellmann's mayonnaise",
      "Roland garlic chili paste"
    ],
    "Beverages": [],
    "Snacks": [],
    "Frozen": [],
    "Canned": [
      "Pickles",
      "Chopped onions",
      "Mixed nuts"
    ],
    "Other": [
      "Organic oregano seasoning",
      "Sliced almonds",
      "Sunflower seeds",
      "Raisins",
      "Crackd egg replacement",
      "Yokii paste"
    ]
  }
}

--- backend/container/fridge_1743074276_5115e30c/recipes_1743074276_5115e30c.json ---
{
  "items": [
    {
      "name": "Fresh Summer Spinach Wraps",
      "total_ingredients": [
        "Fresh spinach leaves",
        "Mixed bell peppers",
        "Carrots",
        "Chopped onions",
        "Tortillas",
        "Organic oregano seasoning",
        "Hellmann's mayonnaise",
        "Sliced almonds",
        "Sunflower seeds",
        "Roland garlic chili paste"
      ],
      "available_ingredients": [
        "Fresh spinach leaves",
        "Mixed bell peppers",
        "Carrots",
        "Chopped onions",
        "Tortillas",
        "Organic oregano seasoning",
        "Hellmann's mayonnaise",
        "Sliced almonds",
        "Sunflower seeds",
        "Roland garlic chili paste"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Thinly slice mixed bell peppers, carrots, and onions.",
        "Step 2: In a bowl, mix chopped vegetables with a spoonful of garlic chili paste and oregano seasoning.",
        "Step 3: Spread mayonnaise over the tortilla.",
        "Step 4: Layer spinach leaves, followed by mixed vegetables, sunflower seeds, and sliced almonds.",
        "Step 5: Roll the tortilla tightly into a wrap.",
        "Step 6: Slice the wrap in halves and serve."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Banana Caramel Cream Dessert",
      "total_ingredients": [
        "Bananas",
        "Philadelphia cream cheese",
        "Maple Grove Farms maple syrup",
        "Mixed nuts",
        "Sliced almonds",
        "Crackd egg replacement",
        "Butter",
        "Brown sugar"
      ],
      "available_ingredients": [
        "Bananas",
        "Philadelphia cream cheese",
        "Maple Grove Farms maple syrup",
        "Mixed nuts",
        "Sliced almonds",
        "Crackd egg replacement",
        "Butter"
      ],
      "missing_ingredients": [
        "Brown sugar"
      ],
      "completeness_score": 88,
      "instructions": [
        "Step 1: Preheat your oven to 350\u00b0F (175\u00b0C).",
        "Step 2: Mash bananas and mix them with Philadelphia cream cheese until smooth.",
        "Step 3: Add maple syrup and Crackd egg replacement to the mixture.",
        "Step 4: Place butter in a skillet and let it melt; add brown sugar (missing) to create a caramel.",
        "Step 5: Add the banana and cream mixture to the skillet and mix.",
        "Step 6: Pour mixture into a baking dish, top with mixed nuts and sliced almonds.",
        "Step 7: Bake for 20 minutes until top is golden brown.",
        "Step 8: Let cool, then chill in the refrigerator before serving."
      ],
      "cooking_time": "50 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Spicy Garlic Chili Pasta",
      "total_ingredients": [
        "Roland garlic chili paste",
        "Hellmann's mayonnaise",
        "Chopped onions",
        "Fresh cilantro",
        "Fresh spinach leaves",
        "Maple Grove Farms maple syrup",
        "Pasta (missing)"
      ],
      "available_ingredients": [
        "Roland garlic chili paste",
        "Hellmann's mayonnaise",
        "Chopped onions",
        "Fresh cilantro",
        "Fresh spinach leaves",
        "Maple Grove Farms maple syrup"
      ],
      "missing_ingredients": [
        "Pasta"
      ],
      "completeness_score": 75,
      "instructions": [
        "Step 1: Boil pasta according to package instructions, drain and set aside.",
        "Step 2: In a pan, saut\u00e9 chopped onions until translucent.",
        "Step 3: Add garlic chili paste, maple syrup, mayonnaise, and a handful of fresh spinach, cook until spinach wilts.",
        "Step 4: Add cooked pasta to the pan, toss to coat with sauce.",
        "Step 5: Garnish with chopped fresh cilantro and serve warm."
      ],
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Fruity Nutty Kale Salad",
      "total_ingredients": [
        "Apples",
        "Pears",
        "Sunflower seeds",
        "Mixed nuts",
        "Organic oregano seasoning",
        "Raisins",
        "Fresh mint",
        "Lemon juice"
      ],
      "available_ingredients": [
        "Apples",
        "Pears",
        "Sunflower seeds",
        "Mixed nuts",
        "Organic oregano seasoning",
        "Raisins",
        "Fresh mint"
      ],
      "missing_ingredients": [
        "Lemon juice"
      ],
      "completeness_score": 86,
      "instructions": [
        "Step 1: Chop apples and pears into bite-sized pieces.",
        "Step 2: In a large salad bowl, combine chopped fruits with sunflower seeds and mixed nuts.",
        "Step 3: Add raisins and freshly chopped mint to the bowl.",
        "Step 4: Sprinkle organic oregano seasoning over the salad.",
        "Step 5: Drizzle with lemon juice (missing), toss gently, and serve chilled."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Citrus Mint Parfait",
      "total_ingredients": [
        "Oranges",
        "Lemons",
        "Philadelphia cream cheese",
        "Hellmann's mayonnaise",
        "Mixed nuts",
        "Fresh mint",
        "Honey (missing)",
        "Granola (missing)"
      ],
      "available_ingredients": [
        "Oranges",
        "Lemons",
        "Philadelphia cream cheese",
        "Hellmann's mayonnaise",
        "Mixed nuts",
        "Fresh mint"
      ],
      "missing_ingredients": [
        "Honey",
        "Granola"
      ],
      "completeness_score": 75,
      "instructions": [
        "Step 1: Peel and section oranges and lemons.",
        "Step 2: Mix Philadelphia cream cheese and Hellmann's mayonnaise in a bowl until creamy.",
        "Step 3: Layer cream mixture in parfait glasses.",
        "Step 4: Top each layer with sections of orange and lemon.",
        "Step 5: Add a sprinkle of mixed nuts and fresh mint.",
        "Step 6: Drizzle with honey (missing) and top with granola (missing) before serving."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Fresh Summer Spinach Wraps",
      "completeness": 100,
      "available_count": 10,
      "missing_count": 0,
      "total_ingredients": 10,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Banana Caramel Cream Dessert",
      "completeness": 88,
      "available_count": 7,
      "missing_count": 1,
      "total_ingredients": 8,
      "cooking_time": "50 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Spicy Garlic Chili Pasta",
      "completeness": 75,
      "available_count": 6,
      "missing_count": 1,
      "total_ingredients": 7,
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Fruity Nutty Kale Salad",
      "completeness": 86,
      "available_count": 7,
      "missing_count": 1,
      "total_ingredients": 8,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Citrus Mint Parfait",
      "completeness": 75,
      "available_count": 6,
      "missing_count": 2,
      "total_ingredients": 8,
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    }
  ],
  "ingredient_count": 28
}

--- backend/container/fridge_1743074341_95b1da55/image_1743074341_95b1da55.jpg ---
[Binary file]

--- backend/container/fridge_1743074341_95b1da55/ingredients_1743074341_95b1da55.json ---
{
  "ingredients": {
    "Dairy": [
      "Hellmann's mayonnaise",
      "Philadelphia cream cheese",
      "Land O'Lakes butter",
      "egg carton"
    ],
    "Produce": [
      "fresh cilantro",
      "fresh mint leaves",
      "red cabbage",
      "carrots",
      "yellow bell pepper",
      "red bell pepper",
      "green bell pepper",
      "orange bell pepper",
      "lemons",
      "limes",
      "oranges",
      "pears",
      "apples",
      "bananas",
      "fresh arugula leaves"
    ],
    "Proteins": [],
    "Grains": [
      "tortilla wraps"
    ],
    "Condiments": [
      "Heinz tomato ketchup",
      "Maple grove farms maple syrup",
      "Annie's dressing",
      "Colemans mustard",
      "sesame paste",
      "Boland curry paste"
    ],
    "Beverages": [
      "bottle partially visible near door"
    ],
    "Snacks": [
      "jar with almonds",
      "jar with dates"
    ],
    "Frozen": [],
    "Canned": [],
    "Other": [
      "jar with pickled vegetables",
      "jar with sunflower seeds",
      "jar with grains"
    ]
  }
}

--- backend/container/fridge_1743074341_95b1da55/recipes_1743074341_95b1da55.json ---
{
  "items": [
    {
      "name": "Colorful Bell Pepper and Arugula Wraps",
      "total_ingredients": [
        "tortilla wraps",
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "yellow bell pepper",
        "red bell pepper",
        "green bell pepper",
        "orange bell pepper",
        "fresh arugula leaves",
        "fresh cilantro",
        "fresh mint leaves",
        "jar with sunflower seeds",
        "Heinz tomato ketchup",
        "lemon juice"
      ],
      "available_ingredients": [
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "yellow bell pepper",
        "red bell pepper",
        "green bell pepper",
        "orange bell pepper",
        "fresh arugula leaves",
        "fresh cilantro",
        "fresh mint leaves",
        "tortilla wraps",
        "Heinz tomato ketchup",
        "jar with sunflower seeds"
      ],
      "missing_ingredients": [
        "lemon juice"
      ],
      "completeness_score": 92,
      "instructions": [
        "Step 1: Chop all bell peppers, cilantro, and mint leaves.",
        "Step 2: In a bowl, mix Philadelphia cream cheese, mayonnaise, chopped herbs, and a squeeze of lemon juice.",
        "Step 3: Spread the mixture onto the tortilla wraps.",
        "Step 4: Top with bell peppers, arugula leaves, and sunflower seeds.",
        "Step 5: Roll the wrap tightly and serve with ketchup."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Red Cabbage and Carrot Slaw with Maple Vinaigrette",
      "total_ingredients": [
        "red cabbage",
        "carrots",
        "Maple grove farms maple syrup",
        "Annie's dressing",
        "Colemans mustard",
        "jar with almonds",
        "jar with sunflower seeds",
        "lemon juice"
      ],
      "available_ingredients": [
        "red cabbage",
        "carrots",
        "Maple grove farms maple syrup",
        "Annie's dressing",
        "Colemans mustard",
        "jar with almonds",
        "jar with sunflower seeds"
      ],
      "missing_ingredients": [
        "lemon juice"
      ],
      "completeness_score": 87,
      "instructions": [
        "Step 1: Shred the red cabbage and carrots into a large bowl.",
        "Step 2: In a separate bowl, whisk together Annie's dressing, maple syrup, Colemans mustard, and a squeeze of lemon juice.",
        "Step 3: Pour the vinaigrette over the slaw and toss to combine.",
        "Step 4: Add almonds and sunflower seeds for crunch and mix well.",
        "Step 5: Chill before serving for best flavor."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Creamy Fruit Delight Parfait",
      "total_ingredients": [
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "Maple grove farms maple syrup",
        "jar with almonds",
        "jar with dates",
        "pears",
        "apples",
        "bananas",
        "oranges"
      ],
      "available_ingredients": [
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "Maple grove farms maple syrup",
        "jar with almonds",
        "jar with dates",
        "pears",
        "apples",
        "bananas",
        "oranges"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Dice pears, apples, bananas, and oranges into small pieces.",
        "Step 2: In a bowl, blend Philadelphia cream cheese with Maple syrup until smooth.",
        "Step 3: Layer fruit pieces alternately with the cream cheese mixture in a tall glass or bowl.",
        "Step 4: Top with chopped almonds and dates.",
        "Step 5: Chill in the refrigerator before serving for a refreshing treat."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Spicy Curried Vegetable and Grain Bowl",
      "total_ingredients": [
        "red cabbage",
        "carrots",
        "Boland curry paste",
        "jar with grains",
        "Land O'Lakes butter",
        "red bell pepper",
        "yellow bell pepper",
        "green bell pepper",
        "orange bell pepper",
        "fresh cilantro",
        "lemons"
      ],
      "available_ingredients": [
        "red cabbage",
        "carrots",
        "Boland curry paste",
        "jar with grains",
        "Land O'Lakes butter",
        "red bell pepper",
        "yellow bell pepper",
        "green bell pepper",
        "orange bell pepper",
        "fresh cilantro",
        "lemons"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Cook the grains as per package instructions.",
        "Step 2: Heat butter in a pan, add curry paste, and stir well.",
        "Step 3: Add chopped bell peppers, cabbage, and carrots to the pan.",
        "Step 4: Cook until vegetables are tender and well coated with curry.",
        "Step 5: Serve the curried vegetables over the grains, topped with fresh cilantro and a squeeze of lemon."
      ],
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Zesty Citrus Herb Salad",
      "total_ingredients": [
        "fresh arugula leaves",
        "oranges",
        "lemons",
        "limes",
        "fresh cilantro",
        "fresh mint leaves",
        "Annie's dressing",
        "jar with almonds"
      ],
      "available_ingredients": [
        "fresh arugula leaves",
        "oranges",
        "lemons",
        "limes",
        "fresh cilantro",
        "fresh mint leaves",
        "Annie's dressing",
        "jar with almonds"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: In a large bowl, combine arugula, chopped cilantro, mint leaves, and almonds.",
        "Step 2: Segment the oranges, lemons, and limes, removing any seeds.",
        "Step 3: Toss citrus segments into the bowl with the greens.",
        "Step 4: Drizzle with Annie's dressing and toss to combine.",
        "Step 5: Serve fresh on its own or as a side dish."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Colorful Bell Pepper and Arugula Wraps",
      "completeness": 92,
      "available_count": 13,
      "missing_count": 1,
      "total_ingredients": 13,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Red Cabbage and Carrot Slaw with Maple Vinaigrette",
      "completeness": 87,
      "available_count": 7,
      "missing_count": 1,
      "total_ingredients": 8,
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Creamy Fruit Delight Parfait",
      "completeness": 100,
      "available_count": 9,
      "missing_count": 0,
      "total_ingredients": 9,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Spicy Curried Vegetable and Grain Bowl",
      "completeness": 100,
      "available_count": 11,
      "missing_count": 0,
      "total_ingredients": 11,
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Zesty Citrus Herb Salad",
      "completeness": 100,
      "available_count": 8,
      "missing_count": 0,
      "total_ingredients": 8,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 32
}

--- backend/main.py ---
import argparse
from flask import Flask

# Import services and config
from config import Config
from services.azure_client import AzureClientService
from services.vision_service import VisionService
from services.recipe_service import RecipeService

from flask_cors import CORS

import sys
sys.dont_write_bytecode = True

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # This enables CORS for all routes

# Global services
config = None
vision_service = None
recipe_service = None

def setup_services():
    """
    Set up the application services
    """
    global config, vision_service, recipe_service
    
    # Initialize configuration
    config = Config()
    
    # Initialize services
    azure_client = AzureClientService(config)
    vision_service = VisionService(azure_client)
    recipe_service = RecipeService(azure_client)
    
    # Import routes after Flask app is initialized
    from api.routes import app as routes_blueprint
    
    # Register blueprint with the main Flask app
    app.register_blueprint(routes_blueprint)
    
    # Provide services to routes module
    import api.routes as routes
    routes.vision_service = vision_service
    routes.recipe_service = recipe_service
    routes.config = config

def main():
    """Main entry point for the application"""
    parser = argparse.ArgumentParser(description="Kitchen Copilot API Server")
    parser.add_argument("--host", default="127.0.0.1", help="Host for API server")
    parser.add_argument("--port", type=int, default=5000, help="Port for API server")
    
    args = parser.parse_args()
    
    # Setup services
    setup_services()
    
    print(f"Starting Kitchen Copilot API server on {args.host}:{args.port}")
    app.run(host=args.host, port=args.port, debug=False)

if __name__ == "__main__":
    main()

--- backend/models/ingredients.py ---
"""
Ingredients Models - Data models for ingredients
"""

from dataclasses import dataclass
from typing import Dict, List

@dataclass
class IngredientsResult:
    """Data class representing ingredients analysis result"""
    ingredients: Dict[str, List[str]]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create an IngredientsResult instance from a dictionary
        
        Args:
            data: Dictionary with ingredients by category
            
        Returns:
            IngredientsResult instance
        """
        if "ingredients" not in data:
            raise ValueError("Invalid ingredients data: 'ingredients' key not found")
        return cls(ingredients=data["ingredients"])
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with ingredients data
        """
        return {
            "ingredients": self.ingredients
        }
    
    def get_all_ingredients(self):
        """
        Get a flattened list of all ingredients
        
        Returns:
            List of all ingredients across categories
        """
        result = []
        for category_items in self.ingredients.values():
            result.extend(category_items)
        return result

--- backend/models/recipes.py ---
"""
Recipe Models - Data models for recipes
"""

from dataclasses import dataclass
from typing import List

@dataclass
class Recipe:
    """Data class representing a single recipe"""
    name: str
    total_ingredients: List[str]
    available_ingredients: List[str]
    missing_ingredients: List[str]
    completeness_score: float
    instructions: List[str]
    cooking_time: str
    difficulty: str
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a Recipe instance from a dictionary
        
        Args:
            data: Dictionary with recipe data
            
        Returns:
            Recipe instance
        """
        return cls(
            name=data["name"],
            total_ingredients=data["total_ingredients"],
            available_ingredients=data["available_ingredients"],
            missing_ingredients=data["missing_ingredients"],
            completeness_score=data["completeness_score"],
            instructions=data["instructions"],
            cooking_time=data["cooking_time"],
            difficulty=data["difficulty"]
        )
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipe data
        """
        return {
            "name": self.name,
            "total_ingredients": self.total_ingredients,
            "available_ingredients": self.available_ingredients,
            "missing_ingredients": self.missing_ingredients,
            "completeness_score": self.completeness_score,
            "instructions": self.instructions,
            "cooking_time": self.cooking_time,
            "difficulty": self.difficulty
        }

@dataclass
class RecipeCollection:
    """Data class representing a collection of recipes"""
    recipes: List[Recipe]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a RecipeCollection instance from a dictionary
        
        Args:
            data: Dictionary with recipes data
            
        Returns:
            RecipeCollection instance
        """
        if "recipes" not in data:
            raise ValueError("Invalid recipes data: 'recipes' key not found")
            
        recipes = [Recipe.from_dict(r) for r in data["recipes"]]
        return cls(recipes=recipes)
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipes data
        """
        return {
            "recipes": [r.to_dict() for r in self.recipes]
        }

--- backend/prompts/recipe_prompt.py ---
"""
Recipe Generation Prompt - System prompt for the recipe generation service
"""

def get_recipe_system_prompt():
    """
    Return the system prompt for recipe generation
    
    Returns:
        String containing the system prompt
    """
    return """You are a creative chef who specializes in creating recipes based on available ingredients.
Your task is to suggest recipes that can be made with the provided ingredients.
For each recipe, you will:
1. Generate the recipe name
2. List all required ingredients (both those provided and those missing)
3. Provide detailed cooking instructions
4. Rate what percentage of necessary ingredients are available

Return your suggestions as a JSON object with the following structure:
{
  "recipes": [
    {
      "name": "Recipe Name",
      "total_ingredients": [list of all ingredients needed],
      "available_ingredients": [list of ingredients from user's inventory],
      "missing_ingredients": [list of ingredients not in user's inventory],
      "completeness_score": 85,  // percentage of available ingredients
      "instructions": ["Step 1...", "Step 2...", ...],
      "cooking_time": "30 minutes",
      "difficulty": "Easy/Medium/Hard"
    },
    ...
  ]
}
"""

--- backend/prompts/vision_prompt.py ---
"""
Vision Analysis Prompt - System prompt for the vision analysis service
"""

def get_vision_system_prompt():
    """
    Return the system prompt for fridge image analysis
    
    Returns:
        String containing the system prompt
    """
    return """You are a helpful kitchen assistant with excellent vision capabilities.
Your task is to:
1. Identify ALL food ingredients and items visible in this refrigerator/kitchen image
2. List as many ingredients as you can possibly identify
3. Be specific about each item (e.g., "fresh spinach leaves" instead of just "vegetables")
4. Organize ingredients into ONLY the following categories:
   - Dairy (milk, cheese, yogurt, butter, etc.)
   - Produce (fruits, vegetables, herbs, etc.)
   - Proteins (meat, poultry, fish, tofu, etc.)
   - Grains (bread, rice, pasta, cereals, etc.)
   - Condiments (sauces, dressings, spreads, etc.)
   - Beverages (drinks, juices, etc.)
   - Snacks (chips, cookies, nuts, etc.)
   - Frozen (ice cream, frozen meals, etc.)
   - Canned (canned vegetables, beans, soups, etc.)
   - Other (any items that don't fit the above categories)
5. Return your analysis as a JSON object with:
   - A key "ingredients" containing an object with these specific category names as keys
   - Each category should contain an array of specific ingredients
   - If a category has no items, include it with an empty array
6. Be thorough and try to identify even partially visible items
7. IMPORTANT: Use ONLY the specified categories above, do not create your own categories"""

--- backend/services/azure_client.py ---
"""
Azure Client Service - Handles Azure OpenAI API client initialization
"""

from openai import AzureOpenAI

class AzureClientService:
    """Service for interacting with Azure OpenAI API"""
    
    def __init__(self, config):
        """
        Initialize the Azure OpenAI client
        
        Args:
            config: Configuration object containing Azure OpenAI credentials
        """
        azure_config = config.get_azure_config()
        self.client = AzureOpenAI(
            api_key=azure_config["api_key"],
            api_version=azure_config["api_version"],
            azure_endpoint=azure_config["endpoint"]
        )
        self.model_name = azure_config["model_name"]
        
    def get_client(self):
        """Get the initialized Azure OpenAI client"""
        return self.client
        
    def get_model_name(self):
        """Get the model name to use for API calls"""
        return self.model_name

--- backend/services/recipe_service.py ---
"""
Recipe Service - Service for generating recipe suggestions based on ingredients
"""

import json
import os
import pandas as pd
from prompts.recipe_prompt import get_recipe_system_prompt

class RecipeService:
    """Service for generating recipes based on available ingredients"""
    
    def __init__(self, azure_client):
        """
        Initialize the Recipe Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def load_ingredients(self, json_path):
        """
        Load and flatten ingredients from JSON file
        
        Args:
            json_path: Path to the JSON file with ingredients
            
        Returns:
            List of ingredient strings
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            # Extract ingredients from the full response
            # Check if it's a full API response or just the ingredients
            if 'result' in data and 'ingredients' in data['result']:
                ingredients_data = data['result']['ingredients']
            elif 'ingredients' in data:
                ingredients_data = data['ingredients']
            else:
                raise ValueError("Could not find ingredients in the JSON file")
            
            # Flatten the ingredients list
            all_ingredients = []
            for category, items in ingredients_data.items():
                all_ingredients.extend(items)
            
            return all_ingredients
        except Exception as e:
            raise Exception(f"Error loading ingredients: {str(e)}")
    
    def generate_recipes(self, ingredients, num_recipes=5):
        """
        Generate recipe suggestions using Azure OpenAI API
        
        Args:
            ingredients: List of available ingredients
            num_recipes: Number of recipes to generate
            
        Returns:
            Dictionary containing recipe suggestions
        """
        ingredients_str = ", ".join(ingredients)
        user_prompt = f"""Here are the ingredients I have available: {ingredients_str}. 
Please suggest {num_recipes} diverse recipes that I could make with these ingredients. 
Include some recipes that use most of what I have, and some creative options that might 
require a few additional ingredients. Focus on wholesome, flavorful dishes."""

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_recipe_system_prompt()},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error generating recipes: {str(e)}")
    
    def save_recipes(self, recipes_data, output_path):
        """
        Save recipes to a JSON file
        
        Args:
            recipes_data: Recipe data (complete response)
            output_path: Path to save the output file
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as f:
            json.dump(recipes_data, f, indent=2)
        return output_path
    
    def get_recipes_analysis(self, recipes_data):
        """
        Create a DataFrame with recipe analysis
        
        Args:
            recipes_data: Recipe data from generate_recipes
            
        Returns:
            DataFrame with recipe analysis or None if no recipes
        """
        # Check if recipes_data is already the full response or just the recipes
        if isinstance(recipes_data, dict) and "recipes" in recipes_data:
            recipes_list = recipes_data["recipes"]
        elif isinstance(recipes_data, dict) and "items" in recipes_data:
            recipes_list = recipes_data["items"]
        else:
            recipes_list = []
        
        if not recipes_list:
            return None
        
        return pd.DataFrame([{
            "recipe_name": r["name"],
            "completeness": r["completeness_score"],
            "available_count": len(r["available_ingredients"]),
            "missing_count": len(r["missing_ingredients"]),
            "total_ingredients": len(r["total_ingredients"]),
            "cooking_time": r["cooking_time"],
            "difficulty": r["difficulty"]
        } for r in recipes_list])

--- backend/services/vision_service.py ---
"""
Vision Service - Service for analyzing fridge/food images
"""

import json
import os
from utils.image_utils import encode_image
from prompts.vision_prompt import get_vision_system_prompt

class VisionService:
    """Service for analyzing food/fridge images using Azure OpenAI Vision API"""
    
    def __init__(self, azure_client):
        """
        Initialize the Vision Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def analyze_image(self, image_path):
        """
        Analyze the image using Azure OpenAI Vision API
        
        Args:
            image_path: Path to the input image
            
        Returns:
            Dictionary containing the analysis results
            
        Raises:
            Exception: If the API call fails or parsing fails
        """
        try:
            base64_image = encode_image(image_path)
            
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_vision_system_prompt()},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "Please identify all the food ingredients and items in this refrigerator image. List as many as you can see and be specific about each item."},
                            {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                        ]
                    }
                ],
                max_tokens=2000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error analyzing image: {str(e)}")
    
    def save_analysis(self, analysis_data, output_path):
        """
        Save the analysis result to a JSON file
        
        Args:
            analysis_data: The complete analysis data to save
            output_path: Path to save the JSON output
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as json_file:
            json.dump(analysis_data, json_file, indent=2)
        
        return output_path
    
    def get_ingredients_summary(self, analysis_result):
        """
        Generate a summary of the ingredients from the analysis
        
        Args:
            analysis_result: The analysis result from analyze_image
            
        Returns:
            Dictionary with summary statistics
        """
        if "ingredients" not in analysis_result:
            return {
                "total_count": 0,
                "categories": 0,
                "by_category": {}
            }
        
        categories = analysis_result["ingredients"]
        by_category = {category: len(items) for category, items in categories.items()}
        total_count = sum(by_category.values())
        
        return {
            "total_count": total_count,
            "categories": len(categories),
            "by_category": by_category
        }

--- backend/utils/image_utils.py ---
"""
Image Utilities - Functions for handling images
"""

import base64
import os
import glob

def encode_image(image_path):
    """
    Encode an image to base64 string
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Base64 encoded string of the image
    
    Raises:
        FileNotFoundError: If the image file doesn't exist
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found at path: {image_path}")
        
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

def find_image_in_folder(folder_path):
    """
    Find the image file in a given folder that follows the naming pattern
    
    Args:
        folder_path: Path to the folder containing the image
        
    Returns:
        Path to the image file or None if not found
    """
    image_files = glob.glob(os.path.join(folder_path, "image_*.*"))
    return image_files[0] if image_files else None

--- requirements.txt ---
numpy==1.26.3
torch 
ultralytics 
opencv-python 
pillow
openai
python-dotenv
uvicorn
fastapi
pydantic
pandas
python-multipart
flask
werkzeug
flask-cors

