Directory Structure:
===================

README.md
assets
├── ImageUpload.png
├── Ingredients.png
└── Recipes.png
backend
├── api
    └── routes.py
├── config.py
├── container
    ├── fridge_c6ae9525
        ├── fridge_c6ae9525.jpg
        ├── ingredients.json
        └── recipes.json
    └── fridge_f22e6749
        ├── fridge_f22e6749.jpg
        ├── ingredients.json
        └── recipes.json
├── main.py
├── models
    ├── ingredients.py
    └── recipes.py
├── prompts
    └── recipe_prompt.py
    └── vision_prompt.py
└── services
    ├── azure_client.py
    └── recipe_service.py
    └── vision_service.py
└── utils
    └── image_utils.py
kitchen-copilot-frontend
requirements.txt
sample-images

File Contents:
=============

--- README.md ---
# Kitchen Copilot

An application that analyses your refrigerator contents through images and suggests recipes based on available ingredients.

![Kitchen Copilot Image Upload Interface](assets/ImageUpload.png)


## Features
- **Image Analysis**: Upload a photo of your fridge or food items to identify ingredients
- **Recipe Generation**: Get customized recipe suggestions based on identified ingredients
- **Dual Operation Modes**: Run as a CLI tool or as an API backend
- **Modern Frontend**: Interactive web interface for easy ingredient analysis and recipe browsing

## Requirements
- Python 3.8+
- Azure OpenAI API access with a deployed GPT-4 Vision model
- Node.js 18+ (for frontend)

## Setup

### Backend Setup
1. Clone the repository
2. Navigate to the project root
3. Install Python dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Copy the `.env.example` file to `.env` and add your Azure OpenAI API keys and settings
5. Install CORS support for the API:
   ```bash
   pip install flask-cors
   ```

### Frontend Setup
1. Navigate to the frontend directory:
   ```bash
   cd kitchen-copilot-frontend
   ```
2. Install dependencies:
   ```bash
   npm install
   ```
3. Create a `.env.local` file with:
   ```
   NEXT_PUBLIC_API_URL=http://localhost:5000
   ```

## Usage

### Running the Full Application
1. Navigate to the backend directory:
   ```bash
   cd backend

2. Start the backend API server:
   ```bash
   python main.py --mode api --host 0.0.0.0 --port 5000
   ```

3. In a separate terminal, start the frontend development server:
   ```bash
   cd kitchen-copilot-frontend
   npm run dev
   ```

3. Open [http://localhost:3000](http://localhost:3000) in your browser to access the application

### Backend CLI Mode
Analyze an image and generate recipes:
```bash
python main.py --mode cli --action both --image fridge.jpg --recipes 5
```

Just analyze an image:
```bash
python main.py --mode cli --action analyze --image fridge.jpg
```

Just generate recipes from previous analysis:
```bash
python main.py --mode cli --action recipes --recipes 7
```

### Backend API Mode
Start the API server alone:
```bash
python main.py --mode api --host 0.0.0.0 --port 5000
```

#### API Endpoints
- `POST /analyze-image`: Upload and analyze a fridge image
- `GET /ingredients`: Get ingredients from the most recent analysis
- `POST /generate-recipes`: Generate recipe suggestions based on available ingredients
- `GET /recipes`: Get previously generated recipes

## Demo Mode

For development and testing purposes, you can visit [http://localhost:3000/demo](http://localhost:3000/demo) to see the frontend with pre-filled sample data, without needing to connect to the backend API.

## Using Postman with the API

You can easily test the API endpoints using Postman. Here's how to make requests to each endpoint:

### 1. Analyze Image Endpoint (POST /analyze-image)

1. Open Postman and create a new POST request to `http://localhost:5000/analyze-image`
2. In the request builder, select the "Body" tab
3. Select "form-data"
4. Add a key named "file" and change the type from "Text" to "File"
5. Click "Select Files" and choose an image of your refrigerator
6. Click "Send" to submit the request

Example response:
```json
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": ["milk", "cheddar cheese", "yogurt"],
      "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
      "Proteins": ["chicken breast", "eggs"],
      "Condiments": ["ketchup", "mayonnaise", "mustard"]
    }
  },
  "summary": {
    "total_count": 10,
    "categories": 4,
    "by_category": {
      "Dairy": 3,
      "Produce": 4,
      "Proteins": 2,
      "Condiments": 3
    }
  },
  "image_filename": "fridge_a1b2c3d4.jpg",
  "request_id": "fridge_a1b2c3d4"
}
```

### 2. Get Ingredients Endpoint (GET /ingredients)

1. Create a new GET request to `http://localhost:5000/ingredients`
2. Optionally, you can add a query parameter named "request_id" if you want to get ingredients from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Ingredients Analysis Display](assets/Ingredients.png)

Example response:
```json
{
  "ingredients": {
    "Dairy": ["milk", "cheddar cheese", "yogurt"],
    "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
    "Proteins": ["chicken breast", "eggs"],
    "Condiments": ["ketchup", "mayonnaise", "mustard"]
  }
}
```

### 3. Get Recipes Endpoint (GET /recipes)

1. Create a new GET request to `http://localhost:5000/recipes`
2. Optionally, you can add a query parameter named "request_id" if you want to get recipes from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Recipe Suggestions Display](assets/Recipes.png)

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

### 4. Generate Recipes Endpoint (POST /generate-recipes)

1. Create a new POST request to `http://localhost:5000/generate-recipes`
2. In the request builder, select the "Body" tab
3. Select "raw" and choose "JSON" from the dropdown
4. Enter the request body:
   ```json
   {
     "num_recipes": 5,
     "request_id": "fridge_630cee49"
   }
   ```
   - Replace "fridge_630cee49" with the actual request_id from your analyze-image response
   - You can omit the request_id to use the most recent analysis
5. Click "Send" to submit the request

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

## Project Structure
```
kitchen-copilot/
├── .env                       # Environment variables
├── backend/                   # Backend directory
│   ├── main.py                # Main entry point
│   ├── config.py              # Configuration and environment loading
│   ├── utils/                 # Utility functions
│   ├── services/              # Core services
│   └── models/                # Data models
├── container/                 # Container data
│   └── fridge/                # Fridge data
│       ├── fridge_c6ae9525/   # Specific fridge instance
│           ├── fridge_c6ae9525.jpg
│           ├── ingredients.json
│           └── recipes.json
├── api/                       # API endpoints
└── kitchen-copilot-frontend/  # Next.js frontend application
    ├── src/                   # Frontend source code
    │   ├── app/               # Next.js app router pages
    │   ├── components/        # React components
    │   ├── lib/               # Utility functions and API client
    │   └── types/             # TypeScript type definitions
    ├── public/                # Static assets
    └── package.json           # Frontend dependencies
```

## Troubleshooting

### CORS Issues
If you encounter CORS errors when the frontend tries to communicate with the backend:

1. Make sure you've installed flask-cors:
   ```bash
   pip install flask-cors
   ```

2. Ensure your main.py includes:
   ```python
   from flask import Flask
   from flask_cors import CORS

   app = Flask(__name__)
   CORS(app)
   ```

### API Connection Issues
- Verify that the backend API is running on the correct host and port
- Check that `NEXT_PUBLIC_API_URL` in the frontend's `.env.local` matches the backend URL
- Try accessing the API directly in the browser (e.g., http://localhost:5000/ingredients)


--- assets/ImageUpload.png ---
[Binary file]

--- assets/Ingredients.png ---
[Binary file]

--- assets/Recipes.png ---
[Binary file]

--- backend/api/routes.py ---
"""
API Routes - FastAPI routes for the application
"""

import os
import json
import shutil
from fastapi import FastAPI, UploadFile, File, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
from typing import Optional
from pydantic import BaseModel

# This will be initialized by main.py
app = FastAPI()

# Store references to services initialized in main.py
vision_service = None
recipe_service = None
config = None

class RecipeRequest(BaseModel):
    """Model for recipe generation request"""
    num_recipes: Optional[int] = 5
    ingredients_file: Optional[str] = None  # If not provided, use latest analysis

async def process_image_async(image_path, output_path):
    """Process image asynchronously"""
    try:
        result = vision_service.analyze_image(image_path)
        vision_service.save_analysis(result, output_path)
        return result
    except Exception as e:
        raise e

@app.post("/analyze-image")
async def analyze_image(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    async_processing: bool = False
):
    """
    Analyze a fridge/food image and identify ingredients
    
    Args:
        file: Uploaded image file
        async_processing: Whether to process the image asynchronously
        
    Returns:
        Analysis result or processing status
    """
    try:
        # Create a unique filename using timestamp
        file_ext = os.path.splitext(file.filename)[1]
        image_filename = f"fridge_{os.urandom(8).hex()}{file_ext}"
        
        # Get file paths
        paths = config.get_file_paths(image_filename)
        
        # Save the uploaded file directly to the results directory
        with open(paths["request_image"], "wb") as image_file:
            shutil.copyfileobj(file.file, image_file)
        
        if async_processing:
            # Process in background
            background_tasks.add_task(
                process_image_async, 
                paths["request_image"], 
                paths["vision_output"]
            )
            return {
                "status": "processing",
                "message": "Image analysis started in background",
                "image_filename": image_filename
            }
        else:
            # Process synchronously
            result = vision_service.analyze_image(paths["request_image"])
            vision_service.save_analysis(result, paths["vision_output"])
            
            # Get a summary
            summary = vision_service.get_ingredients_summary(result)
            
            return {
                "status": "complete",
                "result": result,
                "summary": summary,
                "image_filename": image_filename
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/ingredients")
async def get_ingredients(filename: Optional[str] = None):
    """
    Get ingredients from the most recent analysis or specified file
    
    Args:
        filename: Optional filename to load specific analysis
        
    Returns:
        Ingredients data
    """
    try:
        # Get path to the ingredients file
        if filename:
            ingredients_file = os.path.join(config.results_dir, filename)
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            raise HTTPException(
                status_code=404, 
                detail="No ingredients analysis found. Please analyze an image first."
            )
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return JSONResponse(content=json.load(f))
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/generate-recipes")
async def generate_recipes(request: RecipeRequest):
    """
    Generate recipe suggestions based on available ingredients
    
    Args:
        request: Recipe generation request parameters
        
    Returns:
        Generated recipes
    """
    try:
        # Determine ingredients file path
        if request.ingredients_file:
            ingredients_file = os.path.join(config.results_dir, request.ingredients_file)
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            raise HTTPException(
                status_code=404, 
                detail="No ingredients analysis found. Please analyze an image first."
            )
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=request.num_recipes
        )
        
        # Save recipes
        paths = config.get_file_paths()
        recipe_service.save_recipes(recipes_data, paths["recipes_output"])
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        return {
            "recipes": recipes_data,
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

--- backend/config.py ---
"""
Configuration module - Handles environment variables and configuration
"""

import os
from dotenv import load_dotenv

class Config:
    """Configuration class that loads and provides access to environment variables"""
    
    def __init__(self):
        """Initialize configuration by loading environment variables"""
        load_dotenv()
        self.azure_openai_api_key = os.getenv("AZURE_OPENAI_API_KEY")
        self.azure_openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        self.api_version = os.getenv("API_VERSION")
        self.model_name = os.getenv("MODEL_NAME")
        
        # Default paths
        self.results_dir = os.getenv("RESULTS_DIR", "./data/results")
        
        # Ensure directories exist
        os.makedirs(self.results_dir, exist_ok=True)
    
    def get_azure_config(self):
        """Get Azure OpenAI configuration as a dictionary"""
        return {
            "api_key": self.azure_openai_api_key,
            "api_version": self.api_version,
            "endpoint": self.azure_openai_endpoint,
            "model_name": self.model_name
        }
    
    def get_file_paths(self, image_filename=None):
        """
        Get file paths for input and output files
        
        Args:
            image_filename: Optional image filename to create request-specific paths
            
        Returns:
            Dictionary with paths for input and output files
        """
        if image_filename:
            # Extract the base name without extension for folder naming
            base_name = os.path.splitext(image_filename)[0]
            
            # Create request-specific result directory
            request_dir = os.path.join(self.results_dir, base_name)
            os.makedirs(request_dir, exist_ok=True)
            
            paths = {
                "request_dir": request_dir,
                "vision_output": os.path.join(request_dir, "ingredients.json"),
                "recipes_output": os.path.join(request_dir, "recipes.json"),
                "request_image": os.path.join(request_dir, image_filename)  # Store image in results directory
            }
        else:
            # If no filename is provided, use the most recent request
            # by finding the most recently modified directory in results_dir
            try:
                subdirs = [os.path.join(self.results_dir, d) for d in os.listdir(self.results_dir) 
                        if os.path.isdir(os.path.join(self.results_dir, d))]
                if subdirs:
                    latest_dir = max(subdirs, key=os.path.getmtime)
                    base_image_name = os.path.basename(latest_dir) + ".jpg"  # Assuming jpg extension
                    paths = {
                        "request_dir": latest_dir,
                        "vision_output": os.path.join(latest_dir, "ingredients.json"),
                        "recipes_output": os.path.join(latest_dir, "recipes.json"),
                        "request_image": os.path.join(latest_dir, base_image_name)
                    }
                else:
                    # Fallback to default paths if no subdirectories exist
                    paths = {
                        "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                        "recipes_output": os.path.join(self.results_dir, "recipes.json")
                    }
            except (FileNotFoundError, ValueError):
                # Fallback to default paths if error occurs
                paths = {
                    "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                    "recipes_output": os.path.join(self.results_dir, "recipes.json")
                }
                
        return paths

--- backend/container/fridge_c6ae9525/fridge_c6ae9525.jpg ---
[Binary file]

--- backend/container/fridge_c6ae9525/ingredients.json ---
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": [
        "eggs",
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese",
        "Land O'Lakes butter"
      ],
      "Produce": [
        "red apples",
        "pears",
        "bananas",
        "cilantro",
        "mint",
        "mixed bell peppers",
        "orange",
        "arugula",
        "cucumber",
        "red cabbage",
        "carrots",
        "yellow bell pepper"
      ],
      "Proteins": [],
      "Grains": [
        "corn tortillas"
      ],
      "Condiments": [
        "Heinz tomato ketchup",
        "maple syrup",
        "Annie's dressing",
        "Boland curry paste",
        "English mustard",
        "Werner's horseradish",
        "dijon mustard"
      ],
      "Beverages": [
        "apple juice",
        "Namestea"
      ],
      "Snacks": [
        "cashews"
      ],
      "Frozen": [],
      "Canned": [],
      "Other": [
        "jarred pickled vegetables",
        "jar of seeds"
      ]
    }
  },
  "summary": {
    "total_count": 29,
    "categories": 10,
    "by_category": {
      "Dairy": 4,
      "Produce": 12,
      "Proteins": 0,
      "Grains": 1,
      "Condiments": 7,
      "Beverages": 2,
      "Snacks": 1,
      "Frozen": 0,
      "Canned": 0,
      "Other": 2
    }
  },
  "image_filename": "fridge_c6ae9525.jpg"
}

--- backend/container/fridge_c6ae9525/recipes.json ---
{
  "items": [
    {
      "name": "Curried Veggie Tortilla Wraps",
      "total_ingredients": [
        "corn tortillas",
        "mixed bell peppers",
        "yellow bell pepper",
        "arugula",
        "cucumber",
        "carrots",
        "Boland curry paste",
        "annie\u2019s dressing"
      ],
      "available_ingredients": [
        "corn tortillas",
        "mixed bell peppers",
        "yellow bell pepper",
        "arugula",
        "cucumber",
        "carrots",
        "Boland curry paste",
        "Annie's dressing"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Chop mixed bell peppers, yellow bell pepper, cucumber, and carrots into thin strips.",
        "Step 2: In a bowl, mix 2 tablespoons Boland curry paste with Annie's dressing.",
        "Step 3: Spread the curry dressing generously over the corn tortillas.",
        "Step 4: Lay down arugula on each tortilla.",
        "Step 5: Arrange the chopped vegetables over the arugula.",
        "Step 6: Roll up each tortilla tightly and slice in half."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Creamy Apple & Arugula Salad",
      "total_ingredients": [
        "red apples",
        "pear",
        "Philadelphia cream cheese",
        "Heinz tomato ketchup",
        "arugula",
        "English mustard",
        "jar of seeds"
      ],
      "available_ingredients": [
        "red apples",
        "pear",
        "Philadelphia cream cheese",
        "arugula",
        "English mustard",
        "jar of seeds"
      ],
      "missing_ingredients": [
        "Heinz tomato ketchup"
      ],
      "completeness_score": 86,
      "instructions": [
        "Step 1: Dice the red apples and pears into small cubes.",
        "Step 2: In a salad bowl, mix Philadelphia cream cheese with 1 tablespoon English mustard.",
        "Step 3: Add the diced apples and pears to the bowl and mix well.",
        "Step 4: Toss arugula into the salad mixture.",
        "Step 5: Sprinkle the salad with seeds for crunch.",
        "Step 6: Serve immediately."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Mint & Cilantro Masala Corn Tortilla",
      "total_ingredients": [
        "corn tortillas",
        "mint",
        "cilantro",
        "Boland curry paste",
        "Land O'Lakes butter",
        "jarred pickled vegetables"
      ],
      "available_ingredients": [
        "corn tortillas",
        "mint",
        "cilantro",
        "Boland curry paste",
        "Land O'Lakes butter",
        "jarred pickled vegetables"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Finely chop mint and cilantro.",
        "Step 2: Melt Land O'Lakes butter in a pan.",
        "Step 3: Stir in Boland curry paste into the melted butter.",
        "Step 4: Add mint and cilantro; cook until fragrant.",
        "Step 5: Warm corn tortillas in a separate pan.",
        "Step 6: Spread curry mixture over tortillas.",
        "Step 7: Add pickled vegetables on top and serve warm."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "French Toast with Apple Syrup",
      "total_ingredients": [
        "eggs",
        "maple syrup",
        "red apples",
        "Land O'Lakes butter",
        "Namestea",
        "dijon mustard"
      ],
      "available_ingredients": [
        "eggs",
        "maple syrup",
        "red apples",
        "Land O'Lakes butter",
        "Namestea"
      ],
      "missing_ingredients": [
        "dijon mustard"
      ],
      "completeness_score": 83,
      "instructions": [
        "Step 1: Whisk eggs and Namestea in a bowl.",
        "Step 2: Slice bread and soak in egg mixture.",
        "Step 3: Melt Land O'Lakes butter in a pan.",
        "Step 4: Cook soaked bread until golden brown on both sides.",
        "Step 5: In a saucepan, reduce maple syrup with diced red apples.",
        "Step 6: Drizzle apple syrup over French toast and serve hot."
      ],
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Ketchup Infused Pear & Banana Smoothie",
      "total_ingredients": [
        "pears",
        "bananas",
        "Heinz tomato ketchup",
        "apple juice",
        "cashews",
        "Namestea"
      ],
      "available_ingredients": [
        "pears",
        "bananas",
        "apple juice",
        "cashews",
        "Namestea"
      ],
      "missing_ingredients": [
        "Heinz tomato ketchup"
      ],
      "completeness_score": 83,
      "instructions": [
        "Step 1: Peel and chop pears and bananas.",
        "Step 2: Blend pears, bananas, apple juice, and Namestea until smooth.",
        "Step 3: Add cashews to the smoothie mixture and blend again.",
        "Step 4: For an adventurous twist, drizzle a small amount of Heinz tomato ketchup before serving."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Curried Veggie Tortilla Wraps",
      "completeness": 100,
      "available_count": 8,
      "missing_count": 0,
      "total_ingredients": 8,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Creamy Apple & Arugula Salad",
      "completeness": 86,
      "available_count": 6,
      "missing_count": 1,
      "total_ingredients": 7,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Mint & Cilantro Masala Corn Tortilla",
      "completeness": 100,
      "available_count": 6,
      "missing_count": 0,
      "total_ingredients": 6,
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "French Toast with Apple Syrup",
      "completeness": 83,
      "available_count": 5,
      "missing_count": 1,
      "total_ingredients": 6,
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Ketchup Infused Pear & Banana Smoothie",
      "completeness": 83,
      "available_count": 5,
      "missing_count": 1,
      "total_ingredients": 6,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 29
}

--- backend/container/fridge_f22e6749/fridge_f22e6749.jpg ---
[Binary file]

--- backend/container/fridge_f22e6749/ingredients.json ---
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": [
        "Philadelphia cream cheese",
        "Eggs",
        "Cheese slices (possibly cheddar)"
      ],
      "Produce": [
        "Bunch of fresh cilantro",
        "Bunch of fresh parsley",
        "Fresh mint",
        "Fresh spinach leaves",
        "Green bell pepper",
        "Yellow bell pepper",
        "Orange bell pepper",
        "Red cabbage",
        "Carrots",
        "Apples",
        "Pears",
        "Bananas",
        "Lemons"
      ],
      "Proteins": [],
      "Grains": [
        "Tortillas"
      ],
      "Condiments": [
        "Heinz tomato ketchup",
        "Hellmann's mayonnaise",
        "Annie's dressing",
        "Maple syrup",
        "Soy sauce",
        "Horseradish sauce"
      ],
      "Beverages": [],
      "Snacks": [],
      "Frozen": [],
      "Canned": [
        "Olive tapenade",
        "Sunflower seeds",
        "Almonds",
        "Dried dates",
        "Crispy rye breadsticks"
      ],
      "Other": []
    }
  },
  "summary": {
    "total_count": 28,
    "categories": 10,
    "by_category": {
      "Dairy": 3,
      "Produce": 13,
      "Proteins": 0,
      "Grains": 1,
      "Condiments": 6,
      "Beverages": 0,
      "Snacks": 0,
      "Frozen": 0,
      "Canned": 5,
      "Other": 0
    }
  },
  "image_filename": "fridge_f22e6749.jpg"
}

--- backend/container/fridge_f22e6749/recipes.json ---
{
  "items": [
    {
      "name": "Rainbow Veggie Wraps",
      "total_ingredients": [
        "Tortillas",
        "Philadelphia cream cheese",
        "Fresh spinach leaves",
        "Green bell pepper",
        "Yellow bell pepper",
        "Orange bell pepper",
        "Carrots",
        "Red cabbage",
        "Fresh parsley",
        "Hellmann's mayonnaise",
        "Lemons",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Tortillas",
        "Philadelphia cream cheese",
        "Fresh spinach leaves",
        "Green bell pepper",
        "Yellow bell pepper",
        "Orange bell pepper",
        "Carrots",
        "Red cabbage",
        "Fresh parsley",
        "Hellmann's mayonnaise",
        "Lemons"
      ],
      "missing_ingredients": [
        "Salt",
        "Pepper"
      ],
      "completeness_score": 83,
      "instructions": [
        "Step 1: Spread Philadelphia cream cheese evenly over each tortilla.",
        "Step 2: In a bowl, mix mayonnaise with lemon juice, salt, and pepper.",
        "Step 3: Thinly slice the bell peppers, carrots, and red cabbage.",
        "Step 4: Chop fresh parsley.",
        "Step 5: Layer spinach, bell peppers, carrots, cabbage, and parsley on the tortilla.",
        "Step 6: Drizzle with the prepared mayo mix.",
        "Step 7: Roll the tortillas tightly and cut them in half to serve."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Cheesy Herb Omelette",
      "total_ingredients": [
        "Eggs",
        "Cheese slices (cheddar)",
        "Fresh cilantro",
        "Fresh parsley",
        "Fresh mint",
        "Salt",
        "Pepper",
        "Olive oil"
      ],
      "available_ingredients": [
        "Eggs",
        "Cheese slices (possibly cheddar)",
        "Fresh cilantro",
        "Fresh parsley",
        "Fresh mint"
      ],
      "missing_ingredients": [
        "Salt",
        "Pepper",
        "Olive oil"
      ],
      "completeness_score": 63,
      "instructions": [
        "Step 1: Crack the eggs into a bowl and beat them well.",
        "Step 2: Chop cilantro, parsley, and mint, and add to the eggs.",
        "Step 3: Cut cheese slices into small pieces and add to the egg mixture.",
        "Step 4: Heat olive oil in a non-stick pan over medium heat.",
        "Step 5: Pour the egg mixture into the pan, cook until the eggs set.",
        "Step 6: Season with salt and pepper, fold the omelette, and serve."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Almond Maple Spinach Salad",
      "total_ingredients": [
        "Fresh spinach leaves",
        "Almonds",
        "Maple syrup",
        "Apple cider vinegar",
        "Sunflower seeds",
        "Apples",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Fresh spinach leaves",
        "Almonds",
        "Maple syrup",
        "Sunflower seeds",
        "Apples"
      ],
      "missing_ingredients": [
        "Apple cider vinegar",
        "Salt",
        "Pepper"
      ],
      "completeness_score": 71,
      "instructions": [
        "Step 1: Wash and dry spinach leaves.",
        "Step 2: Slice apples thinly.",
        "Step 3: Toast almonds and sunflower seeds in a pan for a few minutes.",
        "Step 4: Mix maple syrup with apple cider vinegar, salt, and pepper.",
        "Step 5: Combine spinach, apples, almonds, and sunflower seeds in a bowl.",
        "Step 6: Drizzle with the dressing and toss before serving."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Minty Fruit Salad",
      "total_ingredients": [
        "Apples",
        "Pears",
        "Bananas",
        "Fresh mint",
        "Lemons",
        "Maple syrup"
      ],
      "available_ingredients": [
        "Apples",
        "Pears",
        "Bananas",
        "Fresh mint",
        "Lemons",
        "Maple syrup"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Chop apples, pears, and bananas into bite-sized pieces.",
        "Step 2: Tear fresh mint leaves.",
        "Step 3: In a small bowl, mix lemon juice and maple syrup.",
        "Step 4: Combine fruits and mint in a large bowl.",
        "Step 5: Drizzle the lemon syrup mix over the salad and toss gently."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Spicy Veggie Tapenade Tortilla Pizza",
      "total_ingredients": [
        "Tortillas",
        "Olive tapenade",
        "Green bell pepper",
        "Yellow bell pepper",
        "Orange bell pepper",
        "Red cabbage",
        "Cheese slices (possibly cheddar)",
        "Heinz tomato ketchup",
        "Soy sauce",
        "Horseradish sauce"
      ],
      "available_ingredients": [
        "Tortillas",
        "Olive tapenade",
        "Green bell pepper",
        "Yellow bell pepper",
        "Orange bell pepper",
        "Red cabbage",
        "Cheese slices (possibly cheddar)",
        "Heinz tomato ketchup",
        "Soy sauce",
        "Horseradish sauce"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Preheat your oven to 200\u00b0C (390\u00b0F).",
        "Step 2: Spread olive tapenade over the surface of each tortilla.",
        "Step 3: Thinly slice bell peppers and red cabbage.",
        "Step 4: Arrange vegetables over the tapenade layer.",
        "Step 5: Mix ketchup with soy sauce and horseradish sauce, drizzle over veggies.",
        "Step 6: Top with cheese slices.",
        "Step 7: Bake in the oven for 10-12 minutes or until cheese is melted."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Rainbow Veggie Wraps",
      "completeness": 83,
      "available_count": 11,
      "missing_count": 2,
      "total_ingredients": 13,
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Cheesy Herb Omelette",
      "completeness": 63,
      "available_count": 5,
      "missing_count": 3,
      "total_ingredients": 8,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Almond Maple Spinach Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 3,
      "total_ingredients": 8,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Minty Fruit Salad",
      "completeness": 100,
      "available_count": 6,
      "missing_count": 0,
      "total_ingredients": 6,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Spicy Veggie Tapenade Tortilla Pizza",
      "completeness": 100,
      "available_count": 10,
      "missing_count": 0,
      "total_ingredients": 10,
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    }
  ],
  "ingredient_count": 28
}

--- backend/main.py ---
"""
Fridge Recipe Generator - Main entry point for the application

This application:
1. Analyzes fridge/food images to identify ingredients
2. Generates recipe suggestions based on available ingredients

The application can be run in:
- CLI mode for direct command line use
- API mode for integration with other applications or frontends
"""

import argparse
import os
from flask import Flask, request, jsonify
import uuid
import json
from typing import Optional

# Import services and config
from config import Config
from services.azure_client import AzureClientService
from services.vision_service import VisionService
from services.recipe_service import RecipeService

from flask_cors import CORS

# Initialize Flask app
app = Flask(__name__)

CORS(app)  # This enables CORS for all routes

# Global services - will be initialized in setup_api_mode
config = None
vision_service = None
recipe_service = None

class CLIProcessor:
    """Command-line interface processor for the application"""
    
    def __init__(self, config, vision_service, recipe_service):
        """
        Initialize CLI processor
        
        Args:
            config: Configuration object
            vision_service: Vision analysis service
            recipe_service: Recipe generation service
        """
        self.config = config
        self.vision_service = vision_service
        self.recipe_service = recipe_service
    
    def analyze_image(self, image_filename: str) -> dict:
        """
        Analyze a fridge/food image and identify ingredients
        
        Args:
            image_filename: Filename of the image to analyze
            
        Returns:
            Analysis result
        """
        # Check if image already exists in the results directory
        paths = self.config.get_file_paths(image_filename)
        if os.path.exists(paths.get("request_image", "")):
            print(f"Analyzing image: {paths['request_image']}")
            result = self.vision_service.analyze_image(paths["request_image"])
        else:
            raise FileNotFoundError(f"Image file {image_filename} not found in input or results directory")
        
        # Save full result including summary
        summary = self.vision_service.get_ingredients_summary(result)
        full_result = {
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename
        }
        output_path = self.vision_service.save_analysis(full_result, paths["vision_output"])
        print(f"Analysis saved to {output_path}")
        
        # Get summary
        summary = self.vision_service.get_ingredients_summary(result)
        print(f"\nFound {summary['total_count']} ingredients in {summary['categories']} categories:")
        for category, count in summary["by_category"].items():
            print(f"- {category}: {count} items")
        
        return result
    
    def generate_recipes(self, image_filename: Optional[str] = None, num_recipes: int = 5) -> dict:
        """
        Generate recipe suggestions based on available ingredients
        
        Args:
            image_filename: Optional filename of previously analyzed image
            num_recipes: Number of recipes to generate
            
        Returns:
            Generated recipes
        """
        paths = self.config.get_file_paths(image_filename)
        
        # Check if ingredients file exists
        if not os.path.exists(paths["vision_output"]):
            print("No ingredients analysis found. Please analyze an image first.")
            return {}
        
        # Load ingredients
        ingredients = self.recipe_service.load_ingredients(paths["vision_output"])
        print(f"Loaded {len(ingredients)} ingredients from analysis")
        
        # Generate recipes
        print(f"Generating {num_recipes} recipe suggestions...")
        recipes_data = self.recipe_service.generate_recipes(ingredients, num_recipes=num_recipes)
        
        # Save recipes
        output_path = self.recipe_service.save_recipes(recipes_data, paths["recipes_output"])
        print(f"Recipes saved to {output_path}")
        
        # Print recipe analysis
        df = self.recipe_service.get_recipes_analysis(recipes_data)
        if df is not None:
            print("\n==== RECIPE ANALYSIS ====")
            print(df)
        else:
            print("No recipes were generated.")
        
        return recipes_data

# Flask route handlers
@app.route('/analyze-image', methods=['POST'])
def analyze_image():
    """
    Analyze a fridge/food image and identify ingredients
    
    Returns:
        Analysis result or processing status
    """
    try:
        # Check if file was uploaded
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
            
        # Create a unique filename
        file_ext = os.path.splitext(file.filename)[1]
        image_filename = f"fridge_{uuid.uuid4().hex[:8]}{file_ext}"
        
        # Get file paths
        paths = config.get_file_paths(image_filename)
        
        # Save the uploaded file directly to the results directory
        file.save(paths["request_image"])
        
        # Process image
        result = vision_service.analyze_image(paths["request_image"])
        
        # Get a summary
        summary = vision_service.get_ingredients_summary(result)
        
        # Create full response
        full_response = {
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename
        }
        
        # Save the full response
        vision_service.save_analysis(full_response, paths["vision_output"])
        
        # Include request_id (which is the base name of the image)
        request_id = os.path.splitext(image_filename)[0]
        
        return jsonify({
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename,
            "request_id": request_id
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/ingredients', methods=['GET'])
def get_ingredients():
    """
    Get ingredients from the most recent analysis or specified request ID
    
    Returns:
        Ingredients data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    """
    Get recipes from the most recent generation or specified request ID
    
    Returns:
        Recipes data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_file = os.path.join(request_dir, "recipes.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            recipes_file = paths["recipes_output"]
        
        # Check if file exists
        if not os.path.exists(recipes_file):
            return jsonify({
                "error": "No recipes found. Please generate recipes first."
            }), 404
        
        # Load and return the recipes
        with open(recipes_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/generate-recipes', methods=['POST'])
def generate_recipes():
    """
    Generate recipe suggestions based on available ingredients
    
    Returns:
        Generated recipes
    """
    try:
        # Parse request data
        data = request.get_json() or {}
        num_recipes = data.get('num_recipes', 5)
        request_id = data.get('request_id')
        
        # Determine ingredients file path
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=num_recipes
        )
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        # Create full response
        full_response = {
            "items": recipes_data["recipes"],
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
        
        # Determine the recipes output path - use the same request_id if provided
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_output = os.path.join(request_dir, "recipes.json")
        else:
            paths = config.get_file_paths()
            recipes_output = paths["recipes_output"]
        
        # Save the full response
        os.makedirs(os.path.dirname(recipes_output), exist_ok=True)
        with open(recipes_output, "w") as f:
            json.dump(full_response, f, indent=2)
        
        return jsonify(full_response)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def setup_api_mode():
    """
    Set up the application in API mode
    """
    global config, vision_service, recipe_service
    
    # Initialize configuration
    config = Config()
    
    # Initialize services
    azure_client = AzureClientService(config)
    vision_service = VisionService(azure_client)
    recipe_service = RecipeService(azure_client)

def main():
    """Main entry point for the application"""
    parser = argparse.ArgumentParser(description="Fridge Recipe Generator")
    parser.add_argument("--mode", choices=["cli", "api"], default="cli", help="Run mode (cli or api)")
    parser.add_argument("--action", choices=["analyze", "recipes", "both"], default="both", help="Action to perform in CLI mode")
    parser.add_argument("--image", help="Image filename for analysis (in input directory)")
    parser.add_argument("--recipes", type=int, default=5, help="Number of recipes to generate")
    parser.add_argument("--host", default="127.0.0.1", help="Host for API server")
    parser.add_argument("--port", type=int, default=5000, help="Port for API server")
    
    args = parser.parse_args()
    
    if args.mode == "api":
        # API mode
        setup_api_mode()
        print(f"Starting Flask API server on {args.host}:{args.port}")
        app.run(host=args.host, port=args.port, debug=False)
    else:
        # CLI mode
        config = Config()
        azure_client = AzureClientService(config)
        vision_service = VisionService(azure_client)
        recipe_service = RecipeService(azure_client)
        
        cli = CLIProcessor(config, vision_service, recipe_service)
        
        if args.action in ["analyze", "both"]:
            if not args.image:
                print("Error: Image filename required for analysis")
                return
            cli.analyze_image(args.image)
        
        if args.action in ["recipes", "both"]:
            cli.generate_recipes(args.image, args.recipes)

if __name__ == "__main__":
    main()

--- backend/models/ingredients.py ---
"""
Ingredients Models - Data models for ingredients
"""

from dataclasses import dataclass
from typing import Dict, List

@dataclass
class IngredientsResult:
    """Data class representing ingredients analysis result"""
    ingredients: Dict[str, List[str]]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create an IngredientsResult instance from a dictionary
        
        Args:
            data: Dictionary with ingredients by category
            
        Returns:
            IngredientsResult instance
        """
        if "ingredients" not in data:
            raise ValueError("Invalid ingredients data: 'ingredients' key not found")
        return cls(ingredients=data["ingredients"])
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with ingredients data
        """
        return {
            "ingredients": self.ingredients
        }
    
    def get_all_ingredients(self):
        """
        Get a flattened list of all ingredients
        
        Returns:
            List of all ingredients across categories
        """
        result = []
        for category_items in self.ingredients.values():
            result.extend(category_items)
        return result

--- backend/models/recipes.py ---
"""
Recipe Models - Data models for recipes
"""

from dataclasses import dataclass
from typing import List

@dataclass
class Recipe:
    """Data class representing a single recipe"""
    name: str
    total_ingredients: List[str]
    available_ingredients: List[str]
    missing_ingredients: List[str]
    completeness_score: float
    instructions: List[str]
    cooking_time: str
    difficulty: str
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a Recipe instance from a dictionary
        
        Args:
            data: Dictionary with recipe data
            
        Returns:
            Recipe instance
        """
        return cls(
            name=data["name"],
            total_ingredients=data["total_ingredients"],
            available_ingredients=data["available_ingredients"],
            missing_ingredients=data["missing_ingredients"],
            completeness_score=data["completeness_score"],
            instructions=data["instructions"],
            cooking_time=data["cooking_time"],
            difficulty=data["difficulty"]
        )
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipe data
        """
        return {
            "name": self.name,
            "total_ingredients": self.total_ingredients,
            "available_ingredients": self.available_ingredients,
            "missing_ingredients": self.missing_ingredients,
            "completeness_score": self.completeness_score,
            "instructions": self.instructions,
            "cooking_time": self.cooking_time,
            "difficulty": self.difficulty
        }

@dataclass
class RecipeCollection:
    """Data class representing a collection of recipes"""
    recipes: List[Recipe]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a RecipeCollection instance from a dictionary
        
        Args:
            data: Dictionary with recipes data
            
        Returns:
            RecipeCollection instance
        """
        if "recipes" not in data:
            raise ValueError("Invalid recipes data: 'recipes' key not found")
            
        recipes = [Recipe.from_dict(r) for r in data["recipes"]]
        return cls(recipes=recipes)
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipes data
        """
        return {
            "recipes": [r.to_dict() for r in self.recipes]
        }

--- backend/prompts/recipe_prompt.py ---
"""
Recipe Generation Prompt - System prompt for the recipe generation service
"""

def get_recipe_system_prompt():
    """
    Return the system prompt for recipe generation
    
    Returns:
        String containing the system prompt
    """
    return """You are a creative chef who specializes in creating recipes based on available ingredients.
Your task is to suggest recipes that can be made with the provided ingredients.
For each recipe, you will:
1. Generate the recipe name
2. List all required ingredients (both those provided and those missing)
3. Provide detailed cooking instructions
4. Rate what percentage of necessary ingredients are available

Return your suggestions as a JSON object with the following structure:
{
  "recipes": [
    {
      "name": "Recipe Name",
      "total_ingredients": [list of all ingredients needed],
      "available_ingredients": [list of ingredients from user's inventory],
      "missing_ingredients": [list of ingredients not in user's inventory],
      "completeness_score": 85,  // percentage of available ingredients
      "instructions": ["Step 1...", "Step 2...", ...],
      "cooking_time": "30 minutes",
      "difficulty": "Easy/Medium/Hard"
    },
    ...
  ]
}
"""

--- backend/prompts/vision_prompt.py ---
"""
Vision Analysis Prompt - System prompt for the vision analysis service
"""

def get_vision_system_prompt():
    """
    Return the system prompt for fridge image analysis
    
    Returns:
        String containing the system prompt
    """
    return """You are a helpful kitchen assistant with excellent vision capabilities.
Your task is to:
1. Identify ALL food ingredients and items visible in this refrigerator/kitchen image
2. List as many ingredients as you can possibly identify
3. Be specific about each item (e.g., "fresh spinach leaves" instead of just "vegetables")
4. Organize ingredients into ONLY the following categories:
   - Dairy (milk, cheese, yogurt, butter, etc.)
   - Produce (fruits, vegetables, herbs, etc.)
   - Proteins (meat, poultry, fish, tofu, etc.)
   - Grains (bread, rice, pasta, cereals, etc.)
   - Condiments (sauces, dressings, spreads, etc.)
   - Beverages (drinks, juices, etc.)
   - Snacks (chips, cookies, nuts, etc.)
   - Frozen (ice cream, frozen meals, etc.)
   - Canned (canned vegetables, beans, soups, etc.)
   - Other (any items that don't fit the above categories)
5. Return your analysis as a JSON object with:
   - A key "ingredients" containing an object with these specific category names as keys
   - Each category should contain an array of specific ingredients
   - If a category has no items, include it with an empty array
6. Be thorough and try to identify even partially visible items
7. IMPORTANT: Use ONLY the specified categories above, do not create your own categories"""

--- backend/services/azure_client.py ---
"""
Azure Client Service - Handles Azure OpenAI API client initialization
"""

from openai import AzureOpenAI

class AzureClientService:
    """Service for interacting with Azure OpenAI API"""
    
    def __init__(self, config):
        """
        Initialize the Azure OpenAI client
        
        Args:
            config: Configuration object containing Azure OpenAI credentials
        """
        azure_config = config.get_azure_config()
        self.client = AzureOpenAI(
            api_key=azure_config["api_key"],
            api_version=azure_config["api_version"],
            azure_endpoint=azure_config["endpoint"]
        )
        self.model_name = azure_config["model_name"]
        
    def get_client(self):
        """Get the initialized Azure OpenAI client"""
        return self.client
        
    def get_model_name(self):
        """Get the model name to use for API calls"""
        return self.model_name

--- backend/services/recipe_service.py ---
"""
Recipe Service - Service for generating recipe suggestions based on ingredients
"""

import json
import os
import pandas as pd
from prompts.recipe_prompt import get_recipe_system_prompt

class RecipeService:
    """Service for generating recipes based on available ingredients"""
    
    def __init__(self, azure_client):
        """
        Initialize the Recipe Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def load_ingredients(self, json_path):
        """
        Load and flatten ingredients from JSON file
        
        Args:
            json_path: Path to the JSON file with ingredients
            
        Returns:
            List of ingredient strings
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            # Extract ingredients from the full response
            # Check if it's a full API response or just the ingredients
            if 'result' in data and 'ingredients' in data['result']:
                ingredients_data = data['result']['ingredients']
            elif 'ingredients' in data:
                ingredients_data = data['ingredients']
            else:
                raise ValueError("Could not find ingredients in the JSON file")
            
            # Flatten the ingredients list
            all_ingredients = []
            for category, items in ingredients_data.items():
                all_ingredients.extend(items)
            
            return all_ingredients
        except Exception as e:
            raise Exception(f"Error loading ingredients: {str(e)}")
    
    def generate_recipes(self, ingredients, num_recipes=5):
        """
        Generate recipe suggestions using Azure OpenAI API
        
        Args:
            ingredients: List of available ingredients
            num_recipes: Number of recipes to generate
            
        Returns:
            Dictionary containing recipe suggestions
        """
        ingredients_str = ", ".join(ingredients)
        user_prompt = f"""Here are the ingredients I have available: {ingredients_str}. 
Please suggest {num_recipes} diverse recipes that I could make with these ingredients. 
Include some recipes that use most of what I have, and some creative options that might 
require a few additional ingredients. Focus on wholesome, flavorful dishes."""

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_recipe_system_prompt()},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error generating recipes: {str(e)}")
    
    def save_recipes(self, recipes_data, output_path):
        """
        Save recipes to a JSON file
        
        Args:
            recipes_data: Recipe data (complete response)
            output_path: Path to save the output file
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as f:
            json.dump(recipes_data, f, indent=2)
        return output_path
    
    def get_recipes_analysis(self, recipes_data):
        """
        Create a DataFrame with recipe analysis
        
        Args:
            recipes_data: Recipe data from generate_recipes
            
        Returns:
            DataFrame with recipe analysis or None if no recipes
        """
        # Check if recipes_data is already the full response or just the recipes
        if isinstance(recipes_data, dict) and "recipes" in recipes_data:
            recipes_list = recipes_data["recipes"]
        elif isinstance(recipes_data, dict) and "items" in recipes_data:
            recipes_list = recipes_data["items"]
        else:
            recipes_list = []
        
        if not recipes_list:
            return None
        
        return pd.DataFrame([{
            "recipe_name": r["name"],
            "completeness": r["completeness_score"],
            "available_count": len(r["available_ingredients"]),
            "missing_count": len(r["missing_ingredients"]),
            "total_ingredients": len(r["total_ingredients"]),
            "cooking_time": r["cooking_time"],
            "difficulty": r["difficulty"]
        } for r in recipes_list])

--- backend/services/vision_service.py ---
"""
Vision Service - Service for analyzing fridge/food images
"""

import json
import os
from utils.image_utils import encode_image
from prompts.vision_prompt import get_vision_system_prompt

class VisionService:
    """Service for analyzing food/fridge images using Azure OpenAI Vision API"""
    
    def __init__(self, azure_client):
        """
        Initialize the Vision Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def analyze_image(self, image_path):
        """
        Analyze the image using Azure OpenAI Vision API
        
        Args:
            image_path: Path to the input image
            
        Returns:
            Dictionary containing the analysis results
            
        Raises:
            Exception: If the API call fails or parsing fails
        """
        try:
            base64_image = encode_image(image_path)
            
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_vision_system_prompt()},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "Please identify all the food ingredients and items in this refrigerator image. List as many as you can see and be specific about each item."},
                            {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                        ]
                    }
                ],
                max_tokens=2000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error analyzing image: {str(e)}")
    
    def save_analysis(self, analysis_data, output_path):
        """
        Save the analysis result to a JSON file
        
        Args:
            analysis_data: The complete analysis data to save
            output_path: Path to save the JSON output
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as json_file:
            json.dump(analysis_data, json_file, indent=2)
        
        return output_path
    
    def get_ingredients_summary(self, analysis_result):
        """
        Generate a summary of the ingredients from the analysis
        
        Args:
            analysis_result: The analysis result from analyze_image
            
        Returns:
            Dictionary with summary statistics
        """
        if "ingredients" not in analysis_result:
            return {
                "total_count": 0,
                "categories": 0,
                "by_category": {}
            }
        
        categories = analysis_result["ingredients"]
        by_category = {category: len(items) for category, items in categories.items()}
        total_count = sum(by_category.values())
        
        return {
            "total_count": total_count,
            "categories": len(categories),
            "by_category": by_category
        }

--- backend/utils/image_utils.py ---
"""
Image Utilities - Functions for handling images
"""

import base64
import os

def encode_image(image_path):
    """
    Encode an image to base64 string
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Base64 encoded string of the image
    
    Raises:
        FileNotFoundError: If the image file doesn't exist
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found at path: {image_path}")
        
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

--- requirements.txt ---
numpy==1.26.3
torch 
ultralytics 
opencv-python 
pillow
openai
python-dotenv
uvicorn
fastapi
pydantic
pandas
python-multipart
flask
werkzeug
flask-cors

