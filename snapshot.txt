Directory Structure:
===================

README.md
api
└── routes.py
config.py
data
├── prompts
    └── recipe_prompt.py
    └── vision_prompt.py
└── results
    ├── fridge_069ea673
        ├── ingredients.json
        └── recipes.json
    └── fridge_1f005d06
        ├── ingredients.json
        └── recipes.json
input
├── fridge.jpg
├── fridge_069ea673.jpg
└── fridge_1f005d06.jpg
main.py
models
├── ingredients.py
└── recipes.py
requirements.txt
services
├── azure_client.py
└── recipe_service.py
└── vision_service.py
utils
└── image_utils.py

File Contents:
=============

--- README.md ---
# Kitchen Copilot API

An application that analyses your refrigerator contents through images and suggests recipes based on available ingredients.

## Features
- **Image Analysis**: Upload a photo of your fridge or food items to identify ingredients
- **Recipe Generation**: Get customized recipe suggestions based on identified ingredients
- **Dual Operation Modes**: Run as a CLI tool or as an API backend
- **Modern Frontend**: Interactive web interface for easy ingredient analysis and recipe browsing

## Requirements
- Python 3.8+
- Azure OpenAI API access with a deployed GPT-4 Vision model

## Setup

### Backend Setup
1. Clone the repository
2. Navigate to the project root
3. Install Python dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Copy the `.env.example` file to `.env` and add your Azure OpenAI API keys and settings

## Usage

### CLI Mode
Analyze an image and generate recipes:
```bash
python main.py --mode cli --action both --image fridge.jpg --recipes 5
```

Just analyze an image:
```bash
python main.py --mode cli --action analyze --image fridge.jpg
```

Just generate recipes from previous analysis:
```bash
python main.py --mode cli --action recipes --recipes 7
```

### API Mode
Start the API server:
```bash
python main.py --mode api --host 0.0.0.0 --port 5000
```

#### API Endpoints
- `POST /analyze-image`: Upload and analyze a fridge image
- `GET /ingredients`: Get ingredients from the most recent analysis
- `POST /generate-recipes`: Generate recipe suggestions based on available ingredients
- `GET /recipes`: Get previously generated recipes

## Using Postman with the API

You can easily test the API endpoints using Postman. Here's how to make requests to each endpoint:

### 1. Analyze Image Endpoint (POST /analyze-image)

1. Open Postman and create a new POST request to `http://localhost:5000/analyze-image`
2. In the request builder, select the "Body" tab
3. Select "form-data"
4. Add a key named "file" and change the type from "Text" to "File"
5. Click "Select Files" and choose an image of your refrigerator
6. Click "Send" to submit the request

Example response:
```json
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": ["milk", "cheddar cheese", "yogurt"],
      "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
      "Proteins": ["chicken breast", "eggs"],
      "Condiments": ["ketchup", "mayonnaise", "mustard"]
    }
  },
  "summary": {
    "total_count": 10,
    "categories": 4,
    "by_category": {
      "Dairy": 3,
      "Produce": 4,
      "Proteins": 2,
      "Condiments": 3
    }
  },
  "image_filename": "fridge_a1b2c3d4.jpg",
  "request_id": "fridge_a1b2c3d4"
}
```

### 2. Get Ingredients Endpoint (GET /ingredients)

1. Create a new GET request to `http://localhost:5000/ingredients`
2. Optionally, you can add a query parameter named "request_id" if you want to get ingredients from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

Example response:
```json
{
  "ingredients": {
    "Dairy": ["milk", "cheddar cheese", "yogurt"],
    "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
    "Proteins": ["chicken breast", "eggs"],
    "Condiments": ["ketchup", "mayonnaise", "mustard"]
  }
}
```

### 3. Get Recipes Endpoint (GET /recipes)

1. Create a new GET request to `http://localhost:5000/recipes`
2. Optionally, you can add a query parameter named "request_id" if you want to get recipes from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

### 4. Generate Recipes Endpoint (POST /generate-recipes)

1. Create a new POST request to `http://localhost:5000/generate-recipes`
2. In the request builder, select the "Body" tab
3. Select "raw" and choose "JSON" from the dropdown
4. Enter the request body:
   ```json
   {
     "num_recipes": 5,
     "request_id": "fridge_630cee49"
   }
   ```
   - Replace "fridge_630cee49" with the actual request_id from your analyze-image response
   - You can omit the request_id to use the most recent analysis
5. Click "Send" to submit the request

Example response:
Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

## Project Structure
```
fridge-recipes/
├── .env                     # Environment variables
├── main.py                  # Main entry point
├── config.py                # Configuration and environment loading
├── utils/                   # Utility functions
├── services/                # Core services
├── models/                  # Data models
├── data/                    # Data and prompts
│   ├── prompts/             # System prompts
│   └── results/             # Output directory
└── api/                     # API endpoints
```

## Example API Responses

See the Postman section above for example responses from each endpoint.


--- api/routes.py ---
"""
API Routes - FastAPI routes for the application
"""

import os
import json
import shutil
from fastapi import FastAPI, UploadFile, File, HTTPException, BackgroundTasks
from fastapi.responses import JSONResponse
from typing import Optional
from pydantic import BaseModel

# This will be initialized by main.py
app = FastAPI()

# Store references to services initialized in main.py
vision_service = None
recipe_service = None
config = None

class RecipeRequest(BaseModel):
    """Model for recipe generation request"""
    num_recipes: Optional[int] = 5
    ingredients_file: Optional[str] = None  # If not provided, use latest analysis

async def process_image_async(image_path, output_path):
    """Process image asynchronously"""
    try:
        result = vision_service.analyze_image(image_path)
        vision_service.save_analysis(result, output_path)
        return result
    except Exception as e:
        raise e

@app.post("/analyze-image")
async def analyze_image(
    background_tasks: BackgroundTasks,
    file: UploadFile = File(...),
    async_processing: bool = False
):
    """
    Analyze a fridge/food image and identify ingredients
    
    Args:
        file: Uploaded image file
        async_processing: Whether to process the image asynchronously
        
    Returns:
        Analysis result or processing status
    """
    try:
        # Create a unique filename using timestamp
        file_ext = os.path.splitext(file.filename)[1]
        image_filename = f"fridge_{os.urandom(8).hex()}{file_ext}"
        
        # Get file paths
        paths = config.get_file_paths(image_filename)
        
        # Save the uploaded file
        with open(paths["input_image"], "wb") as image_file:
            shutil.copyfileobj(file.file, image_file)
        
        if async_processing:
            # Process in background
            background_tasks.add_task(
                process_image_async, 
                paths["input_image"], 
                paths["vision_output"]
            )
            return {
                "status": "processing",
                "message": "Image analysis started in background",
                "image_filename": image_filename
            }
        else:
            # Process synchronously
            result = vision_service.analyze_image(paths["input_image"])
            vision_service.save_analysis(result, paths["vision_output"])
            
            # Get a summary
            summary = vision_service.get_ingredients_summary(result)
            
            return {
                "status": "complete",
                "result": result,
                "summary": summary,
                "image_filename": image_filename
            }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/ingredients")
async def get_ingredients(filename: Optional[str] = None):
    """
    Get ingredients from the most recent analysis or specified file
    
    Args:
        filename: Optional filename to load specific analysis
        
    Returns:
        Ingredients data
    """
    try:
        # Get path to the ingredients file
        if filename:
            ingredients_file = os.path.join(config.results_dir, filename)
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            raise HTTPException(
                status_code=404, 
                detail="No ingredients analysis found. Please analyze an image first."
            )
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return JSONResponse(content=json.load(f))
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/generate-recipes")
async def generate_recipes(request: RecipeRequest):
    """
    Generate recipe suggestions based on available ingredients
    
    Args:
        request: Recipe generation request parameters
        
    Returns:
        Generated recipes
    """
    try:
        # Determine ingredients file path
        if request.ingredients_file:
            ingredients_file = os.path.join(config.results_dir, request.ingredients_file)
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            raise HTTPException(
                status_code=404, 
                detail="No ingredients analysis found. Please analyze an image first."
            )
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=request.num_recipes
        )
        
        # Save recipes
        paths = config.get_file_paths()
        recipe_service.save_recipes(recipes_data, paths["recipes_output"])
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        return {
            "recipes": recipes_data,
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

--- config.py ---
"""
Configuration module - Handles environment variables and configuration
"""

import os
import time
from dotenv import load_dotenv

class Config:
    """Configuration class that loads and provides access to environment variables"""
    
    def __init__(self):
        """Initialize configuration by loading environment variables"""
        load_dotenv()
        self.azure_openai_api_key = os.getenv("AZURE_OPENAI_API_KEY")
        self.azure_openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        self.api_version = os.getenv("API_VERSION")
        self.model_name = os.getenv("MODEL_NAME")
        
        # Default paths
        self.input_dir = os.getenv("INPUT_DIR", "./input")
        self.results_dir = os.getenv("RESULTS_DIR", "./data/results")
        
        # Ensure directories exist
        os.makedirs(self.input_dir, exist_ok=True)
        os.makedirs(self.results_dir, exist_ok=True)
    
    def get_azure_config(self):
        """Get Azure OpenAI configuration as a dictionary"""
        return {
            "api_key": self.azure_openai_api_key,
            "api_version": self.api_version,
            "endpoint": self.azure_openai_endpoint,
            "model_name": self.model_name
        }
    
    def get_file_paths(self, image_filename=None):
        """
        Get file paths for input and output files
        
        Args:
            image_filename: Optional image filename to create request-specific paths
            
        Returns:
            Dictionary with paths for input and output files
        """
        if image_filename:
            # Extract the base name without extension for folder naming
            base_name = os.path.splitext(image_filename)[0]
            
            # Create request-specific result directory
            request_dir = os.path.join(self.results_dir, base_name)
            os.makedirs(request_dir, exist_ok=True)
            
            paths = {
                "request_dir": request_dir,
                "vision_output": os.path.join(request_dir, "ingredients.json"),
                "recipes_output": os.path.join(request_dir, "recipes.json"),
                "input_image": os.path.join(self.input_dir, image_filename)
            }
        else:
            # If no filename is provided, use the most recent request
            # by finding the most recently modified directory in results_dir
            try:
                subdirs = [os.path.join(self.results_dir, d) for d in os.listdir(self.results_dir) 
                          if os.path.isdir(os.path.join(self.results_dir, d))]
                if subdirs:
                    latest_dir = max(subdirs, key=os.path.getmtime)
                    paths = {
                        "request_dir": latest_dir,
                        "vision_output": os.path.join(latest_dir, "ingredients.json"),
                        "recipes_output": os.path.join(latest_dir, "recipes.json")
                    }
                else:
                    # Fallback to default paths if no subdirectories exist
                    paths = {
                        "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                        "recipes_output": os.path.join(self.results_dir, "recipes.json")
                    }
            except (FileNotFoundError, ValueError):
                # Fallback to default paths if error occurs
                paths = {
                    "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                    "recipes_output": os.path.join(self.results_dir, "recipes.json")
                }
            
        return paths

--- data/prompts/recipe_prompt.py ---
"""
Recipe Generation Prompt - System prompt for the recipe generation service
"""

def get_recipe_system_prompt():
    """
    Return the system prompt for recipe generation
    
    Returns:
        String containing the system prompt
    """
    return """You are a creative chef who specializes in creating recipes based on available ingredients.
Your task is to suggest recipes that can be made with the provided ingredients.
For each recipe, you will:
1. Generate the recipe name
2. List all required ingredients (both those provided and those missing)
3. Provide detailed cooking instructions
4. Rate what percentage of necessary ingredients are available

Return your suggestions as a JSON object with the following structure:
{
  "recipes": [
    {
      "name": "Recipe Name",
      "total_ingredients": [list of all ingredients needed],
      "available_ingredients": [list of ingredients from user's inventory],
      "missing_ingredients": [list of ingredients not in user's inventory],
      "completeness_score": 85,  // percentage of available ingredients
      "instructions": ["Step 1...", "Step 2...", ...],
      "cooking_time": "30 minutes",
      "difficulty": "Easy/Medium/Hard"
    },
    ...
  ]
}
"""

--- data/prompts/vision_prompt.py ---
"""
Vision Analysis Prompt - System prompt for the vision analysis service
"""

def get_vision_system_prompt():
    """
    Return the system prompt for fridge image analysis
    
    Returns:
        String containing the system prompt
    """
    return """You are a helpful kitchen assistant with excellent vision capabilities.
Your task is to:
1. Identify ALL food ingredients and items visible in this refrigerator/kitchen image
2. List as many ingredients as you can possibly identify
3. Be specific about each item (e.g., "fresh spinach leaves" instead of just "vegetables")
4. Organize ingredients into ONLY the following categories:
   - Dairy (milk, cheese, yogurt, butter, etc.)
   - Produce (fruits, vegetables, herbs, etc.)
   - Proteins (meat, poultry, fish, tofu, etc.)
   - Grains (bread, rice, pasta, cereals, etc.)
   - Condiments (sauces, dressings, spreads, etc.)
   - Beverages (drinks, juices, etc.)
   - Snacks (chips, cookies, nuts, etc.)
   - Frozen (ice cream, frozen meals, etc.)
   - Canned (canned vegetables, beans, soups, etc.)
   - Other (any items that don't fit the above categories)
5. Return your analysis as a JSON object with:
   - A key "ingredients" containing an object with these specific category names as keys
   - Each category should contain an array of specific ingredients
   - If a category has no items, include it with an empty array
6. Be thorough and try to identify even partially visible items
7. IMPORTANT: Use ONLY the specified categories above, do not create your own categories"""

--- data/results/fridge_069ea673/ingredients.json ---
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": [
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese",
        "Land O Lakes butter"
      ],
      "Produce": [
        "Bananas",
        "Pears",
        "Apples",
        "Mixed bell peppers (red, yellow, green)",
        "Oranges",
        "Lemons",
        "Limes",
        "Cilantro",
        "Fresh basil",
        "Arugula",
        "Red cabbage",
        "Carrots",
        "Zucchini"
      ],
      "Proteins": [
        "Eggs"
      ],
      "Grains": [
        "Tortillas"
      ],
      "Condiments": [
        "Heinz tomato ketchup",
        "Hellmann's mayonnaise",
        "Organic maple syrup",
        "Annies mustard",
        "Soy sauce",
        "Horseradish",
        "Pickled onions"
      ],
      "Beverages": [
        "White wine (visible on the door)"
      ],
      "Snacks": [],
      "Frozen": [],
      "Canned": [],
      "Other": [
        "Pasta sauce",
        "Almonds",
        "Sunflower seeds",
        "Dates",
        "Pickles"
      ]
    }
  },
  "summary": {
    "total_count": 31,
    "categories": 10,
    "by_category": {
      "Dairy": 3,
      "Produce": 13,
      "Proteins": 1,
      "Grains": 1,
      "Condiments": 7,
      "Beverages": 1,
      "Snacks": 0,
      "Frozen": 0,
      "Canned": 0,
      "Other": 5
    }
  },
  "image_filename": "fridge_069ea673.jpg"
}

--- data/results/fridge_069ea673/recipes.json ---
{
  "items": [
    {
      "name": "Mediterranean Veggie Tortilla Wrap",
      "total_ingredients": [
        "Tortillas",
        "Mixed bell peppers",
        "Red cabbage",
        "Carrots",
        "Zucchini",
        "Fresh basil",
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese",
        "Annies mustard",
        "Lemons",
        "Cilantro"
      ],
      "available_ingredients": [
        "Tortillas",
        "Mixed bell peppers",
        "Red cabbage",
        "Carrots",
        "Zucchini",
        "Fresh basil",
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese",
        "Annies mustard",
        "Lemons",
        "Cilantro"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Thinly slice the mixed bell peppers, red cabbage, carrots, and zucchini.",
        "Step 2: In a bowl, mix Hellmann's mayonnaise, Philadelphia cream cheese, a squeeze of lemon juice, and a teaspoon of Annies mustard.",
        "Step 3: Spread the mixture on tortillas. Layer with sliced vegetables and sprinkle fresh basil and cilantro before rolling the wrap.",
        "Step 4: Roll tightly and serve immediately."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Creamy Lemon Cilantro Pasta",
      "total_ingredients": [
        "Pasta",
        "Philadelphia cream cheese",
        "Cilantro",
        "Lemons",
        "White wine",
        "Red bell peppers",
        "Land O Lakes butter",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Philadelphia cream cheese",
        "Cilantro",
        "Lemons",
        "White wine",
        "Land O Lakes butter"
      ],
      "missing_ingredients": [
        "Pasta",
        "Red bell peppers",
        "Salt",
        "Pepper"
      ],
      "completeness_score": 62,
      "instructions": [
        "Step 1: Cook pasta according to package instructions, drain and set aside.",
        "Step 2: In a pan, melt butter and saut\u00e9 diced red bell peppers until soft.",
        "Step 3: Add Philadelphia cream cheese, a splash of white wine, and juice of a lemon, stir to combine.",
        "Step 4: Toss the pasta in the sauce, season with salt and pepper, and sprinkle with chopped cilantro before serving."
      ],
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Zucchini and Bell Pepper Stir Fry",
      "total_ingredients": [
        "Zucchini",
        "Mixed bell peppers",
        "Soy sauce",
        "Garlic",
        "Limes",
        "Cilantro",
        "Sunflower seeds"
      ],
      "available_ingredients": [
        "Zucchini",
        "Mixed bell peppers",
        "Soy sauce",
        "Limes",
        "Cilantro",
        "Sunflower seeds"
      ],
      "missing_ingredients": [
        "Garlic"
      ],
      "completeness_score": 87,
      "instructions": [
        "Step 1: Slice zucchini and bell peppers into strips.",
        "Step 2: Heat a pan and toast sunflower seeds lightly, then set aside.",
        "Step 3: In the same pan, add soy sauce and lime juice, then stir-fry zucchini and bell peppers for 5 minutes.",
        "Step 4: Add minced garlic, continue stirring for 2 more minutes.",
        "Step 5: Garnish with cilantro and toasted sunflower seeds before serving."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Banana Maple Breakfast Delight",
      "total_ingredients": [
        "Bananas",
        "Organic maple syrup",
        "Philadelphia cream cheese",
        "Tortillas",
        "Almonds"
      ],
      "available_ingredients": [
        "Bananas",
        "Organic maple syrup",
        "Philadelphia cream cheese",
        "Tortillas",
        "Almonds"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Mash bananas in a bowl.",
        "Step 2: Mix the banana mash with Philadelphia cream cheese.",
        "Step 3: Spread the mixture on tortillas and roll them up.",
        "Step 4: Drizzle organic maple syrup on top and garnish with crushed almonds before serving."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Pear and Arugula Salad with Citrus Vinaigrette",
      "total_ingredients": [
        "Pears",
        "Arugula",
        "Lemons",
        "Oranges",
        "Limes",
        "Almonds",
        "Organic maple syrup",
        "Annies mustard",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Pears",
        "Arugula",
        "Lemons",
        "Oranges",
        "Limes",
        "Almonds",
        "Organic maple syrup",
        "Annies mustard"
      ],
      "missing_ingredients": [
        "Salt",
        "Pepper"
      ],
      "completeness_score": 80,
      "instructions": [
        "Step 1: Slice pears thinly and set aside.",
        "Step 2: In a bowl, whisk together juice of lemon, orange, and lime with organic maple syrup and Annies mustard.",
        "Step 3: Season with salt and pepper.",
        "Step 4: In a large bowl, combine arugula and pear slices.",
        "Step 5: Toss with the citrus vinaigrette.",
        "Step 6: Garnish the salad with sliced almonds before serving."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Mediterranean Veggie Tortilla Wrap",
      "completeness": 100,
      "available_count": 11,
      "missing_count": 0,
      "total_ingredients": 11,
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Creamy Lemon Cilantro Pasta",
      "completeness": 62,
      "available_count": 5,
      "missing_count": 4,
      "total_ingredients": 9,
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Zucchini and Bell Pepper Stir Fry",
      "completeness": 87,
      "available_count": 6,
      "missing_count": 1,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Banana Maple Breakfast Delight",
      "completeness": 100,
      "available_count": 5,
      "missing_count": 0,
      "total_ingredients": 5,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Pear and Arugula Salad with Citrus Vinaigrette",
      "completeness": 80,
      "available_count": 8,
      "missing_count": 2,
      "total_ingredients": 10,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 31
}

--- data/results/fridge_1f005d06/ingredients.json ---
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": [
        "eggs",
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "block of cheese"
      ],
      "Produce": [
        "cilantro",
        "mint",
        "red cabbage",
        "carrots",
        "yellow bell pepper",
        "red bell pepper",
        "green bell pepper",
        "lime",
        "parsley",
        "arugula",
        "bananas",
        "oranges",
        "lemons",
        "red apples",
        "green apples",
        "pears",
        "grape tomatoes"
      ],
      "Proteins": [],
      "Grains": [
        "tortillas"
      ],
      "Condiments": [
        "Hellmann's mayonnaise",
        "Heinz tomato ketchup",
        "maple syrup",
        "Annie's salad dressing",
        "Yokki sesame paste",
        "jar of pickles",
        "Horseradish sauce",
        "creamy Dijon mustard",
        "honey",
        "Capers"
      ],
      "Beverages": [
        "bottle of white wine"
      ],
      "Snacks": [
        "almonds",
        "dates",
        "jar of olives"
      ],
      "Frozen": [],
      "Canned": [],
      "Other": [
        "jar of sunflower seeds",
        "jar of oats",
        "jar of spaghetti",
        "jar of rice crackers",
        "jar of preserved lemons"
      ]
    }
  },
  "summary": {
    "total_count": 41,
    "categories": 10,
    "by_category": {
      "Dairy": 4,
      "Produce": 17,
      "Proteins": 0,
      "Grains": 1,
      "Condiments": 10,
      "Beverages": 1,
      "Snacks": 3,
      "Frozen": 0,
      "Canned": 0,
      "Other": 5
    }
  },
  "image_filename": "fridge_1f005d06.jpg"
}

--- data/results/fridge_1f005d06/recipes.json ---
{
  "items": [
    {
      "name": "Bell Pepper and Creamy Herb Savory Omelette",
      "total_ingredients": [
        "eggs",
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "cilantro",
        "mint",
        "red bell pepper",
        "green bell pepper",
        "yellow bell pepper",
        "salt",
        "pepper"
      ],
      "available_ingredients": [
        "eggs",
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "cilantro",
        "mint",
        "red bell pepper",
        "green bell pepper",
        "yellow bell pepper"
      ],
      "missing_ingredients": [
        "salt",
        "pepper"
      ],
      "completeness_score": 80,
      "instructions": [
        "Step 1: Beat 4 eggs in a bowl and season with salt and pepper.",
        "Step 2: Chop the bell peppers, cilantro, and mint finely.",
        "Step 3: Heat a pan and add a tablespoon of Land O'Lakes butter.",
        "Step 4: Saut\u00e9 the bell peppers until soft, then add them to the beaten eggs.",
        "Step 5: Pour the egg mixture into the pan and cook on low heat.",
        "Step 6: Add small dollops of cream cheese and fold the omelette when the edges are set.",
        "Step 7: Cook until the omelette is fully cooked and serve with a garnish of cilantro and mint."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Cheesy Spice Roasted Carrot and Cabbage Rolls",
      "total_ingredients": [
        "red cabbage",
        "carrots",
        "block of cheese",
        "cilantro",
        "Hellmann's mayonnaise",
        "cream cheese",
        "spices"
      ],
      "available_ingredients": [
        "red cabbage",
        "carrots",
        "block of cheese",
        "cilantro",
        "Hellmann's mayonnaise",
        "Philadelphia cream cheese"
      ],
      "missing_ingredients": [
        "spices"
      ],
      "completeness_score": 86,
      "instructions": [
        "Step 1: Preheat oven to 375\u00b0F (190\u00b0C).",
        "Step 2: Peel and slice carrots lengthwise. Steam them until tender.",
        "Step 3: Remove outer leaves of red cabbage and blanch them in hot water for 1 minute.",
        "Step 4: Grate the block of cheese and mix with cream cheese, chopped cilantro, and spices.",
        "Step 5: Spread mayonnaise on cabbage leaves, place a carrot slice and cheese mixture, and roll it up.",
        "Step 6: Place rolls in a baking dish and bake for 20 minutes until the cheese is melted and bubbly.",
        "Step 7: Serve warm garnished with more cilantro."
      ],
      "cooking_time": "40 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Minted Arugula and Apple Fresh Salad",
      "total_ingredients": [
        "arugula",
        "red apples",
        "green apples",
        "mint",
        "lime",
        "Annie's salad dressing",
        "almonds"
      ],
      "available_ingredients": [
        "arugula",
        "red apples",
        "green apples",
        "mint",
        "lime",
        "Annie's salad dressing",
        "almonds"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Core and thinly slice red and green apples.",
        "Step 2: In a salad bowl, combine arugula, sliced apples, and chopped mint.",
        "Step 3: Squeeze lime juice over the salad.",
        "Step 4: Roughly chop almonds and sprinkle over the salad.",
        "Step 5: Drizzle with Annie's salad dressing and toss gently.",
        "Step 6: Serve immediately as a refreshing side."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Sweet and Savory Citrus Glazed Spaghetti",
      "total_ingredients": [
        "jar of spaghetti",
        "Land O'Lakes butter",
        "oranges",
        "lemons",
        "honey",
        "creamy Dijon mustard",
        "almonds",
        "parsley"
      ],
      "available_ingredients": [
        "jar of spaghetti",
        "Land O'Lakes butter",
        "oranges",
        "lemons",
        "honey",
        "creamy Dijon mustard",
        "almonds",
        "parsley"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Cook the jar of spaghetti according to package directions and drain.",
        "Step 2: Zest and juice the oranges and lemons.",
        "Step 3: In a skillet, melt Land O'Lakes butter and add honey, citrus zest and juice, and creamy Dijon mustard.",
        "Step 4: Simmer until slightly thickened, then toss cooked spaghetti with the glaze.",
        "Step 5: Roughly chop almonds and garnish the pasta along with parsley.",
        "Step 6: Serve with additional parsley and enjoy warm."
      ],
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Crispy Rice Cracker and Pickled Veggie Tapas",
      "total_ingredients": [
        "jar of rice crackers",
        "jar of pickles",
        "jar of olives",
        "Philadelphia cream cheese",
        "parsley",
        "Capers"
      ],
      "available_ingredients": [
        "jar of rice crackers",
        "jar of pickles",
        "jar of olives",
        "Philadelphia cream cheese",
        "parsley",
        "Capers"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Spread a small amount of Philadelphia cream cheese on each rice cracker.",
        "Step 2: Thinly slice pickles and arrange on top of the cream cheese.",
        "Step 3: Halve the olives and place a slice on each cracker.",
        "Step 4: Sprinkle capers and freshly chopped parsley over the top.",
        "Step 5: Serve as a light snack or appetizer."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Bell Pepper and Creamy Herb Savory Omelette",
      "completeness": 80,
      "available_count": 8,
      "missing_count": 2,
      "total_ingredients": 10,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Cheesy Spice Roasted Carrot and Cabbage Rolls",
      "completeness": 86,
      "available_count": 6,
      "missing_count": 1,
      "total_ingredients": 7,
      "cooking_time": "40 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Minted Arugula and Apple Fresh Salad",
      "completeness": 100,
      "available_count": 7,
      "missing_count": 0,
      "total_ingredients": 7,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Sweet and Savory Citrus Glazed Spaghetti",
      "completeness": 100,
      "available_count": 8,
      "missing_count": 0,
      "total_ingredients": 8,
      "cooking_time": "25 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Crispy Rice Cracker and Pickled Veggie Tapas",
      "completeness": 100,
      "available_count": 6,
      "missing_count": 0,
      "total_ingredients": 6,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 41
}

--- input/fridge.jpg ---
[Binary file]

--- input/fridge_069ea673.jpg ---
[Binary file]

--- input/fridge_1f005d06.jpg ---
[Binary file]

--- main.py ---
"""
Fridge Recipe Generator - Main entry point for the application

This application:
1. Analyzes fridge/food images to identify ingredients
2. Generates recipe suggestions based on available ingredients

The application can be run in:
- CLI mode for direct command line use
- API mode for integration with other applications or frontends
"""

import argparse
import os
from flask import Flask, request, jsonify, send_from_directory
from werkzeug.utils import secure_filename
import uuid
import glob
import time
import json
from typing import Optional

# Import services and config
from config import Config
from services.azure_client import AzureClientService
from services.vision_service import VisionService
from services.recipe_service import RecipeService

# Initialize Flask app
app = Flask(__name__)

# Global services - will be initialized in setup_api_mode
config = None
vision_service = None
recipe_service = None

class CLIProcessor:
    """Command-line interface processor for the application"""
    
    def __init__(self, config, vision_service, recipe_service):
        """
        Initialize CLI processor
        
        Args:
            config: Configuration object
            vision_service: Vision analysis service
            recipe_service: Recipe generation service
        """
        self.config = config
        self.vision_service = vision_service
        self.recipe_service = recipe_service
    
    def analyze_image(self, image_filename: str) -> dict:
        """
        Analyze a fridge/food image and identify ingredients
        
        Args:
            image_filename: Filename of the image to analyze
            
        Returns:
            Analysis result
        """
        paths = self.config.get_file_paths(image_filename)
        print(f"Analyzing image: {paths['input_image']}")
        
        # Run analysis
        result = self.vision_service.analyze_image(paths["input_image"])
        
        # Save full result including summary
        summary = self.vision_service.get_ingredients_summary(result)
        full_result = {
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename
        }
        output_path = self.vision_service.save_analysis(full_result, paths["vision_output"])
        print(f"Analysis saved to {output_path}")
        
        # Get summary
        summary = self.vision_service.get_ingredients_summary(result)
        print(f"\nFound {summary['total_count']} ingredients in {summary['categories']} categories:")
        for category, count in summary["by_category"].items():
            print(f"- {category}: {count} items")
        
        return result
    
    def generate_recipes(self, image_filename: Optional[str] = None, num_recipes: int = 5) -> dict:
        """
        Generate recipe suggestions based on available ingredients
        
        Args:
            image_filename: Optional filename of previously analyzed image
            num_recipes: Number of recipes to generate
            
        Returns:
            Generated recipes
        """
        paths = self.config.get_file_paths(image_filename)
        
        # Check if ingredients file exists
        if not os.path.exists(paths["vision_output"]):
            print("No ingredients analysis found. Please analyze an image first.")
            return {}
        
        # Load ingredients
        ingredients = self.recipe_service.load_ingredients(paths["vision_output"])
        print(f"Loaded {len(ingredients)} ingredients from analysis")
        
        # Generate recipes
        print(f"Generating {num_recipes} recipe suggestions...")
        recipes_data = self.recipe_service.generate_recipes(ingredients, num_recipes=num_recipes)
        
        # Save recipes
        output_path = self.recipe_service.save_recipes(recipes_data, paths["recipes_output"])
        print(f"Recipes saved to {output_path}")
        
        # Print recipe analysis
        df = self.recipe_service.get_recipes_analysis(recipes_data)
        if df is not None:
            print("\n==== RECIPE ANALYSIS ====")
            print(df)
        else:
            print("No recipes were generated.")
        
        return recipes_data

# Flask route handlers
@app.route('/analyze-image', methods=['POST'])
def analyze_image():
    """
    Analyze a fridge/food image and identify ingredients
    
    Returns:
        Analysis result or processing status
    """
    try:
        # Check if file was uploaded
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
            
        # Create a unique filename
        file_ext = os.path.splitext(file.filename)[1]
        image_filename = f"fridge_{uuid.uuid4().hex[:8]}{file_ext}"
        
        # Get file paths
        paths = config.get_file_paths(image_filename)
        
        # Save the uploaded file
        file.save(paths["input_image"])
        
        # Process image
        result = vision_service.analyze_image(paths["input_image"])
        
        # Get a summary
        summary = vision_service.get_ingredients_summary(result)
        
        # Create full response
        full_response = {
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename
        }
        
        # Save the full response
        vision_service.save_analysis(full_response, paths["vision_output"])
        
        # Include request_id (which is the base name of the image)
        request_id = os.path.splitext(image_filename)[0]
        
        return jsonify({
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename,
            "request_id": request_id
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/ingredients', methods=['GET'])
def get_ingredients():
    """
    Get ingredients from the most recent analysis or specified request ID
    
    Returns:
        Ingredients data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    """
    Get recipes from the most recent generation or specified request ID
    
    Returns:
        Recipes data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_file = os.path.join(request_dir, "recipes.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            recipes_file = paths["recipes_output"]
        
        # Check if file exists
        if not os.path.exists(recipes_file):
            return jsonify({
                "error": "No recipes found. Please generate recipes first."
            }), 404
        
        # Load and return the recipes
        with open(recipes_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/generate-recipes', methods=['POST'])
def generate_recipes():
    """
    Generate recipe suggestions based on available ingredients
    
    Returns:
        Generated recipes
    """
    try:
        # Parse request data
        data = request.get_json() or {}
        num_recipes = data.get('num_recipes', 5)
        request_id = data.get('request_id')
        
        # Determine ingredients file path
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=num_recipes
        )
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        # Create full response
        full_response = {
            "items": recipes_data["recipes"],
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
        
        # Determine the recipes output path - use the same request_id if provided
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_output = os.path.join(request_dir, "recipes.json")
        else:
            paths = config.get_file_paths()
            recipes_output = paths["recipes_output"]
        
        # Save the full response
        os.makedirs(os.path.dirname(recipes_output), exist_ok=True)
        with open(recipes_output, "w") as f:
            json.dump(full_response, f, indent=2)
        
        return jsonify(full_response)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

def setup_api_mode():
    """
    Set up the application in API mode
    """
    global config, vision_service, recipe_service
    
    # Initialize configuration
    config = Config()
    
    # Initialize services
    azure_client = AzureClientService(config)
    vision_service = VisionService(azure_client)
    recipe_service = RecipeService(azure_client)

def main():
    """Main entry point for the application"""
    parser = argparse.ArgumentParser(description="Fridge Recipe Generator")
    parser.add_argument("--mode", choices=["cli", "api"], default="cli", help="Run mode (cli or api)")
    parser.add_argument("--action", choices=["analyze", "recipes", "both"], default="both", help="Action to perform in CLI mode")
    parser.add_argument("--image", help="Image filename for analysis (in input directory)")
    parser.add_argument("--recipes", type=int, default=5, help="Number of recipes to generate")
    parser.add_argument("--host", default="127.0.0.1", help="Host for API server")
    parser.add_argument("--port", type=int, default=5000, help="Port for API server")
    
    args = parser.parse_args()
    
    if args.mode == "api":
        # API mode
        setup_api_mode()
        print(f"Starting Flask API server on {args.host}:{args.port}")
        app.run(host=args.host, port=args.port, debug=False)
    else:
        # CLI mode
        config = Config()
        azure_client = AzureClientService(config)
        vision_service = VisionService(azure_client)
        recipe_service = RecipeService(azure_client)
        
        cli = CLIProcessor(config, vision_service, recipe_service)
        
        if args.action in ["analyze", "both"]:
            if not args.image:
                print("Error: Image filename required for analysis")
                return
            cli.analyze_image(args.image)
        
        if args.action in ["recipes", "both"]:
            cli.generate_recipes(args.image, args.recipes)

if __name__ == "__main__":
    main()

--- models/ingredients.py ---
"""
Ingredients Models - Data models for ingredients
"""

from dataclasses import dataclass
from typing import Dict, List

@dataclass
class IngredientsResult:
    """Data class representing ingredients analysis result"""
    ingredients: Dict[str, List[str]]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create an IngredientsResult instance from a dictionary
        
        Args:
            data: Dictionary with ingredients by category
            
        Returns:
            IngredientsResult instance
        """
        if "ingredients" not in data:
            raise ValueError("Invalid ingredients data: 'ingredients' key not found")
        return cls(ingredients=data["ingredients"])
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with ingredients data
        """
        return {
            "ingredients": self.ingredients
        }
    
    def get_all_ingredients(self):
        """
        Get a flattened list of all ingredients
        
        Returns:
            List of all ingredients across categories
        """
        result = []
        for category_items in self.ingredients.values():
            result.extend(category_items)
        return result

--- models/recipes.py ---
"""
Recipe Models - Data models for recipes
"""

from dataclasses import dataclass
from typing import List

@dataclass
class Recipe:
    """Data class representing a single recipe"""
    name: str
    total_ingredients: List[str]
    available_ingredients: List[str]
    missing_ingredients: List[str]
    completeness_score: float
    instructions: List[str]
    cooking_time: str
    difficulty: str
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a Recipe instance from a dictionary
        
        Args:
            data: Dictionary with recipe data
            
        Returns:
            Recipe instance
        """
        return cls(
            name=data["name"],
            total_ingredients=data["total_ingredients"],
            available_ingredients=data["available_ingredients"],
            missing_ingredients=data["missing_ingredients"],
            completeness_score=data["completeness_score"],
            instructions=data["instructions"],
            cooking_time=data["cooking_time"],
            difficulty=data["difficulty"]
        )
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipe data
        """
        return {
            "name": self.name,
            "total_ingredients": self.total_ingredients,
            "available_ingredients": self.available_ingredients,
            "missing_ingredients": self.missing_ingredients,
            "completeness_score": self.completeness_score,
            "instructions": self.instructions,
            "cooking_time": self.cooking_time,
            "difficulty": self.difficulty
        }

@dataclass
class RecipeCollection:
    """Data class representing a collection of recipes"""
    recipes: List[Recipe]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a RecipeCollection instance from a dictionary
        
        Args:
            data: Dictionary with recipes data
            
        Returns:
            RecipeCollection instance
        """
        if "recipes" not in data:
            raise ValueError("Invalid recipes data: 'recipes' key not found")
            
        recipes = [Recipe.from_dict(r) for r in data["recipes"]]
        return cls(recipes=recipes)
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipes data
        """
        return {
            "recipes": [r.to_dict() for r in self.recipes]
        }

--- requirements.txt ---
numpy==1.26.3
torch 
ultralytics 
opencv-python 
pillow
openai
python-dotenv
uvicorn
fastapi
pydantic
pandas
python-multipart
flask
werkzeug

--- services/azure_client.py ---
"""
Azure Client Service - Handles Azure OpenAI API client initialization
"""

from openai import AzureOpenAI

class AzureClientService:
    """Service for interacting with Azure OpenAI API"""
    
    def __init__(self, config):
        """
        Initialize the Azure OpenAI client
        
        Args:
            config: Configuration object containing Azure OpenAI credentials
        """
        azure_config = config.get_azure_config()
        self.client = AzureOpenAI(
            api_key=azure_config["api_key"],
            api_version=azure_config["api_version"],
            azure_endpoint=azure_config["endpoint"]
        )
        self.model_name = azure_config["model_name"]
        
    def get_client(self):
        """Get the initialized Azure OpenAI client"""
        return self.client
        
    def get_model_name(self):
        """Get the model name to use for API calls"""
        return self.model_name

--- services/recipe_service.py ---
"""
Recipe Service - Service for generating recipe suggestions based on ingredients
"""

import json
import os
import pandas as pd
from data.prompts.recipe_prompt import get_recipe_system_prompt

class RecipeService:
    """Service for generating recipes based on available ingredients"""
    
    def __init__(self, azure_client):
        """
        Initialize the Recipe Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def load_ingredients(self, json_path):
        """
        Load and flatten ingredients from JSON file
        
        Args:
            json_path: Path to the JSON file with ingredients
            
        Returns:
            List of ingredient strings
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            # Extract ingredients from the full response
            # Check if it's a full API response or just the ingredients
            if 'result' in data and 'ingredients' in data['result']:
                ingredients_data = data['result']['ingredients']
            elif 'ingredients' in data:
                ingredients_data = data['ingredients']
            else:
                raise ValueError("Could not find ingredients in the JSON file")
            
            # Flatten the ingredients list
            all_ingredients = []
            for category, items in ingredients_data.items():
                all_ingredients.extend(items)
            
            return all_ingredients
        except Exception as e:
            raise Exception(f"Error loading ingredients: {str(e)}")
    
    def generate_recipes(self, ingredients, num_recipes=5):
        """
        Generate recipe suggestions using Azure OpenAI API
        
        Args:
            ingredients: List of available ingredients
            num_recipes: Number of recipes to generate
            
        Returns:
            Dictionary containing recipe suggestions
        """
        ingredients_str = ", ".join(ingredients)
        user_prompt = f"""Here are the ingredients I have available: {ingredients_str}. 
Please suggest {num_recipes} diverse recipes that I could make with these ingredients. 
Include some recipes that use most of what I have, and some creative options that might 
require a few additional ingredients. Focus on wholesome, flavorful dishes."""

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_recipe_system_prompt()},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error generating recipes: {str(e)}")
    
    def save_recipes(self, recipes_data, output_path):
        """
        Save recipes to a JSON file
        
        Args:
            recipes_data: Recipe data (complete response)
            output_path: Path to save the output file
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as f:
            json.dump(recipes_data, f, indent=2)
        return output_path
    
    def get_recipes_analysis(self, recipes_data):
        """
        Create a DataFrame with recipe analysis
        
        Args:
            recipes_data: Recipe data from generate_recipes
            
        Returns:
            DataFrame with recipe analysis or None if no recipes
        """
        # Check if recipes_data is already the full response or just the recipes
        if isinstance(recipes_data, dict) and "recipes" in recipes_data:
            recipes_list = recipes_data["recipes"]
        elif isinstance(recipes_data, dict) and "items" in recipes_data:
            recipes_list = recipes_data["items"]
        else:
            recipes_list = []
        
        if not recipes_list:
            return None
        
        return pd.DataFrame([{
            "recipe_name": r["name"],
            "completeness": r["completeness_score"],
            "available_count": len(r["available_ingredients"]),
            "missing_count": len(r["missing_ingredients"]),
            "total_ingredients": len(r["total_ingredients"]),
            "cooking_time": r["cooking_time"],
            "difficulty": r["difficulty"]
        } for r in recipes_list])

--- services/vision_service.py ---
"""
Vision Service - Service for analyzing fridge/food images
"""

import json
import os
from utils.image_utils import encode_image
from data.prompts.vision_prompt import get_vision_system_prompt

class VisionService:
    """Service for analyzing food/fridge images using Azure OpenAI Vision API"""
    
    def __init__(self, azure_client):
        """
        Initialize the Vision Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def analyze_image(self, image_path):
        """
        Analyze the image using Azure OpenAI Vision API
        
        Args:
            image_path: Path to the input image
            
        Returns:
            Dictionary containing the analysis results
            
        Raises:
            Exception: If the API call fails or parsing fails
        """
        try:
            base64_image = encode_image(image_path)
            
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_vision_system_prompt()},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "Please identify all the food ingredients and items in this refrigerator image. List as many as you can see and be specific about each item."},
                            {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                        ]
                    }
                ],
                max_tokens=2000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error analyzing image: {str(e)}")
    
    def save_analysis(self, analysis_data, output_path):
        """
        Save the analysis result to a JSON file
        
        Args:
            analysis_data: The complete analysis data to save
            output_path: Path to save the JSON output
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as json_file:
            json.dump(analysis_data, json_file, indent=2)
        
        return output_path
    
    def get_ingredients_summary(self, analysis_result):
        """
        Generate a summary of the ingredients from the analysis
        
        Args:
            analysis_result: The analysis result from analyze_image
            
        Returns:
            Dictionary with summary statistics
        """
        if "ingredients" not in analysis_result:
            return {
                "total_count": 0,
                "categories": 0,
                "by_category": {}
            }
        
        categories = analysis_result["ingredients"]
        by_category = {category: len(items) for category, items in categories.items()}
        total_count = sum(by_category.values())
        
        return {
            "total_count": total_count,
            "categories": len(categories),
            "by_category": by_category
        }

--- utils/image_utils.py ---
"""
Image Utilities - Functions for handling images
"""

import base64
import os

def encode_image(image_path):
    """
    Encode an image to base64 string
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Base64 encoded string of the image
    
    Raises:
        FileNotFoundError: If the image file doesn't exist
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found at path: {image_path}")
        
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

