Directory Structure:
===================

README.md
assets
├── ImageUpload.png
├── Ingredients.png
└── Recipes.png
backend
├── api
    └── routes.py
├── config.py
├── container
    ├── fridge_84771ad40e8d8afc
        ├── fridge_84771ad40e8d8afc.jpg
        ├── ingredients.json
        └── recipes.json
    └── fridge_d1ea98cc4b729f52
        ├── fridge_d1ea98cc4b729f52.jpg
        ├── ingredients.json
        └── recipes.json
├── main.py
├── models
    ├── ingredients.py
    └── recipes.py
├── prompts
    └── recipe_prompt.py
    └── vision_prompt.py
└── services
    ├── azure_client.py
    └── recipe_service.py
    └── vision_service.py
└── utils
    └── image_utils.py
kitchen-copilot-frontend
requirements.txt
sample-images

File Contents:
=============

--- README.md ---
# Kitchen Copilot

An application that analyses your refrigerator contents through images and suggests recipes based on available ingredients.

![Kitchen Copilot Image Upload Interface](assets/ImageUpload.png)


## Features
- **Image Analysis**: Upload a photo of your fridge or food items to identify ingredients
- **Recipe Generation**: Get customized recipe suggestions based on identified ingredients
- **Dual Operation Modes**: Run as a CLI tool or as an API backend
- **Modern Frontend**: Interactive web interface for easy ingredient analysis and recipe browsing

## Requirements
- Python 3.8+
- Azure OpenAI API access with a deployed GPT-4 Vision model
- Node.js 18+ (for frontend)

## Setup

### Backend Setup
1. Clone the repository
2. Navigate to the project root
3. Install Python dependencies:
   ```bash
   pip install -r requirements.txt
   ```
4. Copy the `.env.example` file to `.env` and add your Azure OpenAI API keys and settings
5. Install CORS support for the API:
   ```bash
   pip install flask-cors
   ```

### Frontend Setup
1. Navigate to the frontend directory:
   ```bash
   cd kitchen-copilot-frontend
   ```
2. Install dependencies:
   ```bash
   npm install
   ```
3. Create a `.env.local` file with:
   ```
   NEXT_PUBLIC_API_URL=http://localhost:5000
   ```

## Usage

### Running the Full Application
1. Navigate to the backend directory:
   ```bash
   cd backend

2. Start the backend API server:
   ```bash
   python main.py --mode api --host 0.0.0.0 --port 5000
   ```

3. In a separate terminal, start the frontend development server:
   ```bash
   cd kitchen-copilot-frontend
   npm run dev
   ```

3. Open [http://localhost:3000](http://localhost:3000) in your browser to access the application

### Backend CLI Mode
Analyze an image and generate recipes:
```bash
python main.py --mode cli --action both --image fridge.jpg --recipes 5
```

Just analyze an image:
```bash
python main.py --mode cli --action analyze --image fridge.jpg
```

Just generate recipes from previous analysis:
```bash
python main.py --mode cli --action recipes --recipes 7
```

### Backend API Mode
Start the API server alone:
```bash
python main.py --mode api --host 0.0.0.0 --port 5000
```

#### API Endpoints
- `POST /analyze-image`: Upload and analyze a fridge image
- `GET /ingredients`: Get ingredients from the most recent analysis
- `POST /generate-recipes`: Generate recipe suggestions based on available ingredients
- `GET /recipes`: Get previously generated recipes

## Demo Mode

For development and testing purposes, you can visit [http://localhost:3000/demo](http://localhost:3000/demo) to see the frontend with pre-filled sample data, without needing to connect to the backend API.

## Using Postman with the API

You can easily test the API endpoints using Postman. Here's how to make requests to each endpoint:

### 1. Analyze Image Endpoint (POST /analyze-image)

1. Open Postman and create a new POST request to `http://localhost:5000/analyze-image`
2. In the request builder, select the "Body" tab
3. Select "form-data"
4. Add a key named "file" and change the type from "Text" to "File"
5. Click "Select Files" and choose an image of your refrigerator
6. Click "Send" to submit the request

Example response:
```json
{
  "status": "complete",
  "result": {
    "ingredients": {
      "Dairy": ["milk", "cheddar cheese", "yogurt"],
      "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
      "Proteins": ["chicken breast", "eggs"],
      "Condiments": ["ketchup", "mayonnaise", "mustard"]
    }
  },
  "summary": {
    "total_count": 10,
    "categories": 4,
    "by_category": {
      "Dairy": 3,
      "Produce": 4,
      "Proteins": 2,
      "Condiments": 3
    }
  },
  "image_filename": "fridge_a1b2c3d4.jpg",
  "request_id": "fridge_a1b2c3d4"
}
```

### 2. Get Ingredients Endpoint (GET /ingredients)

1. Create a new GET request to `http://localhost:5000/ingredients`
2. Optionally, you can add a query parameter named "request_id" if you want to get ingredients from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Ingredients Analysis Display](assets/Ingredients.png)

Example response:
```json
{
  "ingredients": {
    "Dairy": ["milk", "cheddar cheese", "yogurt"],
    "Produce": ["carrots", "lettuce", "tomatoes", "onions"],
    "Proteins": ["chicken breast", "eggs"],
    "Condiments": ["ketchup", "mayonnaise", "mustard"]
  }
}
```

### 3. Get Recipes Endpoint (GET /recipes)

1. Create a new GET request to `http://localhost:5000/recipes`
2. Optionally, you can add a query parameter named "request_id" if you want to get recipes from a specific analysis
   - The request_id is returned in the analyze-image response (e.g., "fridge_630cee49")
3. Click "Send" to submit the request

![Recipe Suggestions Display](assets/Recipes.png)

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

### 4. Generate Recipes Endpoint (POST /generate-recipes)

1. Create a new POST request to `http://localhost:5000/generate-recipes`
2. In the request builder, select the "Body" tab
3. Select "raw" and choose "JSON" from the dropdown
4. Enter the request body:
   ```json
   {
     "num_recipes": 5,
     "request_id": "fridge_630cee49"
   }
   ```
   - Replace "fridge_630cee49" with the actual request_id from your analyze-image response
   - You can omit the request_id to use the most recent analysis
5. Click "Send" to submit the request

Example response:
```json
{
  "items": [
    {
      "name": "Quick Chicken Salad",
      "total_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise", "salt", "pepper"],
      "available_ingredients": ["chicken breast", "lettuce", "tomatoes", "onions", "mayonnaise"],
      "missing_ingredients": ["salt", "pepper"],
      "completeness_score": 71,
      "instructions": ["Step 1...", "Step 2..."],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Quick Chicken Salad",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 10
}
```

## Project Structure
```
kitchen-copilot/
├── .env                       # Environment variables
├── backend/                   # Backend directory
│   ├── main.py                # Main entry point
│   ├── config.py              # Configuration and environment loading
│   ├── utils/                 # Utility functions
│   ├── services/              # Core services
│   └── models/                # Data models
├── container/                 # Container data
│   └── fridge/                # Fridge data
│       ├── fridge_c6ae9525/   # Specific fridge instance
│           ├── fridge_c6ae9525.jpg
│           ├── ingredients.json
│           └── recipes.json
├── api/                       # API endpoints
└── kitchen-copilot-frontend/  # Next.js frontend application
    ├── src/                   # Frontend source code
    │   ├── app/               # Next.js app router pages
    │   ├── components/        # React components
    │   ├── lib/               # Utility functions and API client
    │   └── types/             # TypeScript type definitions
    ├── public/                # Static assets
    └── package.json           # Frontend dependencies
```

## Troubleshooting

### CORS Issues
If you encounter CORS errors when the frontend tries to communicate with the backend:

1. Make sure you've installed flask-cors:
   ```bash
   pip install flask-cors
   ```

2. Ensure your main.py includes:
   ```python
   from flask import Flask
   from flask_cors import CORS

   app = Flask(__name__)
   CORS(app)
   ```

### API Connection Issues
- Verify that the backend API is running on the correct host and port
- Check that `NEXT_PUBLIC_API_URL` in the frontend's `.env.local` matches the backend URL
- Try accessing the API directly in the browser (e.g., http://localhost:5000/ingredients)


--- assets/ImageUpload.png ---
[Binary file]

--- assets/Ingredients.png ---
[Binary file]

--- assets/Recipes.png ---
[Binary file]

--- backend/api/routes.py ---
"""
API Routes - Flask routes for the Kitchen Copilot application

This module preserves the exact API interface expected by the frontend,
while using Flask instead of FastAPI for implementation.
"""

import os
import json
from flask import Blueprint, request, jsonify

# Create a Blueprint instead of a Flask app
app = Blueprint('api', __name__)

# Store references to services initialized in main.py
vision_service = None
recipe_service = None
config = None

@app.route('/analyze-image', methods=['POST'])
def analyze_image():
    """
    Analyze a fridge/food image and identify ingredients
    
    Returns:
        Analysis result or processing status
    """
    try:
        # Check if file was uploaded
        if 'file' not in request.files:
            return jsonify({"error": "No file part in the request"}), 400
            
        file = request.files['file']
        if file.filename == '':
            return jsonify({"error": "No file selected"}), 400
            
        # Create a unique filename using timestamp
        file_ext = os.path.splitext(file.filename)[1]
        image_filename = f"fridge_{os.urandom(8).hex()}{file_ext}"
        
        # Get file paths
        paths = config.get_file_paths(image_filename)
        
        # Save the uploaded file directly to the results directory
        os.makedirs(os.path.dirname(paths["request_image"]), exist_ok=True)
        file.save(paths["request_image"])
        
        # Process synchronously
        result = vision_service.analyze_image(paths["request_image"])
        vision_service.save_analysis(result, paths["vision_output"])
        
        # Get a summary
        summary = vision_service.get_ingredients_summary(result)
        
        # Include request_id (which is the base name of the image)
        request_id = os.path.splitext(image_filename)[0]
        
        return jsonify({
            "status": "complete",
            "result": result,
            "summary": summary,
            "image_filename": image_filename,
            "request_id": request_id
        })
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/ingredients', methods=['GET'])
def get_ingredients():
    """
    Get ingredients from the most recent analysis or specified request ID
    
    Returns:
        Ingredients data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load and return the ingredients
        with open(ingredients_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/recipes', methods=['GET'])
def get_recipes():
    """
    Get recipes from the most recent generation or specified request ID
    
    Returns:
        Recipes data
    """
    try:
        # Get request ID (folder name) from query parameter
        request_id = request.args.get('request_id')
        
        if request_id:
            # Look for the request folder
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_file = os.path.join(request_dir, "recipes.json")
        else:
            # Use most recent analysis
            paths = config.get_file_paths()
            recipes_file = paths["recipes_output"]
        
        # Check if file exists
        if not os.path.exists(recipes_file):
            return jsonify({
                "error": "No recipes found. Please generate recipes first."
            }), 404
        
        # Load and return the recipes
        with open(recipes_file, "r") as f:
            return jsonify(json.load(f))
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route('/generate-recipes', methods=['POST'])
def generate_recipes():
    """
    Generate recipe suggestions based on available ingredients
    
    Returns:
        Generated recipes
    """
    try:
        # Parse request data
        data = request.get_json() or {}
        num_recipes = data.get('num_recipes', 5)
        request_id = data.get('request_id')
        
        # Determine ingredients file path
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            ingredients_file = os.path.join(request_dir, "ingredients.json")
        else:
            paths = config.get_file_paths()
            ingredients_file = paths["vision_output"]
        
        # Check if file exists
        if not os.path.exists(ingredients_file):
            return jsonify({
                "error": "No ingredients analysis found. Please analyze an image first."
            }), 404
        
        # Load ingredients
        ingredients = recipe_service.load_ingredients(ingredients_file)
        
        # Generate recipes
        recipes_data = recipe_service.generate_recipes(
            ingredients, 
            num_recipes=num_recipes
        )
        
        # Get analysis
        analysis = recipe_service.get_recipes_analysis(recipes_data)
        analysis_dict = analysis.to_dict('records') if analysis is not None else []
        
        # Create full response
        full_response = {
            "items": recipes_data["recipes"],
            "analysis": analysis_dict,
            "ingredient_count": len(ingredients)
        }
        
        # Determine the recipes output path - use the same request_id if provided
        if request_id:
            request_dir = os.path.join(config.results_dir, request_id)
            recipes_output = os.path.join(request_dir, "recipes.json")
        else:
            paths = config.get_file_paths()
            recipes_output = paths["recipes_output"]
        
        # Save the full response
        os.makedirs(os.path.dirname(recipes_output), exist_ok=True)
        with open(recipes_output, "w") as f:
            json.dump(full_response, f, indent=2)
        
        return jsonify(full_response)
    except Exception as e:
        return jsonify({"error": str(e)}), 500

--- backend/config.py ---
"""
Configuration module - Handles environment variables and configuration
"""

import os
from dotenv import load_dotenv

class Config:
    """Configuration class that loads and provides access to environment variables"""
    
    def __init__(self):
        """Initialize configuration by loading environment variables"""
        load_dotenv()
        self.azure_openai_api_key = os.getenv("AZURE_OPENAI_API_KEY")
        self.azure_openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT")
        self.api_version = os.getenv("API_VERSION")
        self.model_name = os.getenv("MODEL_NAME")
        
        # Default paths
        self.results_dir = os.getenv("RESULTS_DIR", "./data/results")
        
        # Ensure directories exist
        os.makedirs(self.results_dir, exist_ok=True)
    
    def get_azure_config(self):
        """Get Azure OpenAI configuration as a dictionary"""
        return {
            "api_key": self.azure_openai_api_key,
            "api_version": self.api_version,
            "endpoint": self.azure_openai_endpoint,
            "model_name": self.model_name
        }
    
    def get_file_paths(self, image_filename=None):
        """
        Get file paths for input and output files
        
        Args:
            image_filename: Optional image filename to create request-specific paths
            
        Returns:
            Dictionary with paths for input and output files
        """
        if image_filename:
            # Extract the base name without extension for folder naming
            base_name = os.path.splitext(image_filename)[0]
            
            # Create request-specific result directory
            request_dir = os.path.join(self.results_dir, base_name)
            os.makedirs(request_dir, exist_ok=True)
            
            paths = {
                "request_dir": request_dir,
                "vision_output": os.path.join(request_dir, "ingredients.json"),
                "recipes_output": os.path.join(request_dir, "recipes.json"),
                "request_image": os.path.join(request_dir, image_filename)  # Store image in results directory
            }
        else:
            # If no filename is provided, use the most recent request
            # by finding the most recently modified directory in results_dir
            try:
                subdirs = [os.path.join(self.results_dir, d) for d in os.listdir(self.results_dir) 
                        if os.path.isdir(os.path.join(self.results_dir, d))]
                if subdirs:
                    latest_dir = max(subdirs, key=os.path.getmtime)
                    base_image_name = os.path.basename(latest_dir) + ".jpg"  # Assuming jpg extension
                    paths = {
                        "request_dir": latest_dir,
                        "vision_output": os.path.join(latest_dir, "ingredients.json"),
                        "recipes_output": os.path.join(latest_dir, "recipes.json"),
                        "request_image": os.path.join(latest_dir, base_image_name)
                    }
                else:
                    # Fallback to default paths if no subdirectories exist
                    paths = {
                        "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                        "recipes_output": os.path.join(self.results_dir, "recipes.json")
                    }
            except (FileNotFoundError, ValueError):
                # Fallback to default paths if error occurs
                paths = {
                    "vision_output": os.path.join(self.results_dir, "ingredients.json"),
                    "recipes_output": os.path.join(self.results_dir, "recipes.json")
                }
                
        return paths

--- backend/container/fridge_84771ad40e8d8afc/fridge_84771ad40e8d8afc.jpg ---
[Binary file]

--- backend/container/fridge_84771ad40e8d8afc/ingredients.json ---
{
  "ingredients": {
    "Dairy": [
      "Philadelphia cream cheese",
      "Parmesan cheese block",
      "Eggs (in carton)"
    ],
    "Produce": [
      "Red cabbage",
      "Carrots",
      "Yellow bell pepper",
      "Red tomatoes",
      "Cucumber",
      "Fresh spinach leaves",
      "Fresh cilantro",
      "Fresh mint",
      "Bananas",
      "Pears",
      "Apples",
      "Lemons",
      "Oranges",
      "Limes"
    ],
    "Proteins": [
      "Eggs (in carton)"
    ],
    "Grains": [
      "Flour tortillas",
      "Bread"
    ],
    "Condiments": [
      "Heinz tomato ketchup",
      "Hellmann's mayonnaise",
      "Maple syrup",
      "Annie's mustard",
      "Boland's pasta sauce",
      "Soy sauce",
      "Floyd's pickled onions"
    ],
    "Beverages": [],
    "Snacks": [
      "Almonds",
      "Dates"
    ],
    "Frozen": [],
    "Canned": [],
    "Other": [
      "Sunflower seeds",
      "Rice"
    ]
  }
}

--- backend/container/fridge_84771ad40e8d8afc/recipes.json ---
{
  "items": [
    {
      "name": "Garden Fresh Veggie Wraps",
      "total_ingredients": [
        "Flour tortillas",
        "Red cabbage",
        "Carrots",
        "Yellow bell pepper",
        "Cucumber",
        "Fresh spinach leaves",
        "Philadelphia cream cheese",
        "Annie's mustard",
        "Lemons",
        "Fresh cilantro"
      ],
      "available_ingredients": [
        "Flour tortillas",
        "Red cabbage",
        "Carrots",
        "Yellow bell pepper",
        "Cucumber",
        "Fresh spinach leaves",
        "Philadelphia cream cheese",
        "Annie's mustard",
        "Lemons",
        "Fresh cilantro"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Slice the carrots, yellow bell pepper, cucumber, and red cabbage into thin strips.",
        "Mix Philadelphia cream cheese, a squeeze of lemon juice, and chopped fresh cilantro to make a spread.",
        "Lay a flour tortilla flat and spread the cream cheese mixture evenly.",
        "Arrange spinach leaves, sliced vegetables, and a drizzle of Annie's mustard on top.",
        "Roll the tortilla tightly and slice in half for serving."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Spinach and Cheese Frittata",
      "total_ingredients": [
        "Eggs",
        "Fresh spinach leaves",
        "Parmesan cheese block",
        "Hellmann's mayonnaise",
        "Red tomatoes",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Eggs",
        "Fresh spinach leaves",
        "Parmesan cheese block",
        "Hellmann's mayonnaise",
        "Red tomatoes"
      ],
      "missing_ingredients": [
        "Salt",
        "Pepper"
      ],
      "completeness_score": 85,
      "instructions": [
        "Preheat the oven to 350\u00b0F (175\u00b0C).",
        "Whisk eggs and add a tablespoon of Hellmann's mayonnaise for creaminess.",
        "Grate Parmesan cheese and chop fresh spinach leaves.",
        "Dice red tomatoes.",
        "Mix eggs, spinach, tomatoes, and grated cheese, then season with salt and pepper.",
        "Pour the mixture into a greased baking dish.",
        "Bake for 20-25 minutes, or until the frittata has set in the center."
      ],
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Fruity Breakfast Bowl",
      "total_ingredients": [
        "Bananas",
        "Pears",
        "Apples",
        "Almonds",
        "Dates",
        "Sunflower seeds",
        "Maple syrup",
        "Fresh mint"
      ],
      "available_ingredients": [
        "Bananas",
        "Pears",
        "Apples",
        "Almonds",
        "Dates",
        "Sunflower seeds",
        "Maple syrup",
        "Fresh mint"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Chop bananas, pears, and apples into bite-sized pieces.",
        "Finely chop dates.",
        "In a bowl, combine chopped fruits and mix well.",
        "Top with almonds, sunflower seeds, and chopped dates.",
        "Drizzle maple syrup over the top.",
        "Garnish with fresh mint leaves prior to serving."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Citrus-Glazed Carrot and Almond Salad",
      "total_ingredients": [
        "Carrots",
        "Lemons",
        "Oranges",
        "Almonds",
        "Soy sauce",
        "Fresh cilantro",
        "Fresh mint",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Carrots",
        "Lemons",
        "Oranges",
        "Almonds",
        "Soy sauce",
        "Fresh cilantro",
        "Fresh mint"
      ],
      "missing_ingredients": [
        "Salt",
        "Pepper"
      ],
      "completeness_score": 88,
      "instructions": [
        "Peel and grate the carrots into a salad bowl.",
        "Toast almonds in a dry pan until lightly brown and fragrant.",
        "In a small bowl, mix the juice of lemons and oranges with a dash of soy sauce.",
        "Pour the citrus dressing over the grated carrots and toss well.",
        "Add toasted almonds and toss again.",
        "Garnish with chopped fresh cilantro and mint.",
        "Season with salt and pepper to taste."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Tomato Basil Rice",
      "total_ingredients": [
        "Rice",
        "Red tomatoes",
        "Boland's pasta sauce",
        "Philadelphia cream cheese",
        "Fresh basil (substitute with cilantro)",
        "Parmesan cheese block",
        "Salt",
        "Pepper"
      ],
      "available_ingredients": [
        "Rice",
        "Red tomatoes",
        "Boland's pasta sauce",
        "Philadelphia cream cheese",
        "Parmesan cheese block"
      ],
      "missing_ingredients": [
        "Fresh basil",
        "Salt",
        "Pepper"
      ],
      "completeness_score": 71,
      "instructions": [
        "Cook the rice according to package instructions.",
        "Dice tomatoes and stir them into Boland's pasta sauce.",
        "Add a spoonful of Philadelphia cream cheese into the sauce for creaminess.",
        "Stir the sauce into the cooked rice.",
        "Grate Parmesan cheese and fold it into the rice mixture.",
        "Garnish with chopped fresh basil or finely chopped cilantro if basil is unavailable.",
        "Season with salt and pepper to taste."
      ],
      "cooking_time": "35 minutes",
      "difficulty": "Medium"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Garden Fresh Veggie Wraps",
      "completeness": 100,
      "available_count": 10,
      "missing_count": 0,
      "total_ingredients": 10,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Spinach and Cheese Frittata",
      "completeness": 85,
      "available_count": 5,
      "missing_count": 2,
      "total_ingredients": 7,
      "cooking_time": "30 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Fruity Breakfast Bowl",
      "completeness": 100,
      "available_count": 8,
      "missing_count": 0,
      "total_ingredients": 8,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Citrus-Glazed Carrot and Almond Salad",
      "completeness": 88,
      "available_count": 7,
      "missing_count": 2,
      "total_ingredients": 9,
      "cooking_time": "20 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Tomato Basil Rice",
      "completeness": 71,
      "available_count": 5,
      "missing_count": 3,
      "total_ingredients": 8,
      "cooking_time": "35 minutes",
      "difficulty": "Medium"
    }
  ],
  "ingredient_count": 31
}

--- backend/container/fridge_d1ea98cc4b729f52/fridge_d1ea98cc4b729f52.jpg ---
[Binary file]

--- backend/container/fridge_d1ea98cc4b729f52/ingredients.json ---
{
  "ingredients": {
    "Dairy": [
      "Philadelphia cream cheese",
      "Land O'Lakes butter",
      "Hellmann's mayonnaise"
    ],
    "Produce": [
      "Bananas",
      "Pears",
      "Apples",
      "Cilantro",
      "Mint",
      "Mixed bell peppers",
      "Red cabbage",
      "Yellow bell pepper",
      "Carrots",
      "Arugula"
    ],
    "Proteins": [
      "Eggs",
      "Mozzarella cheese ball"
    ],
    "Grains": [
      "Tortillas"
    ],
    "Condiments": [
      "Heinz tomato ketchup",
      "Maple Grove Farms syrup",
      "Annie's mustard",
      "Roland kalamata olive paste",
      "Yokki sesame paste",
      "Colman's mustard",
      "Heinz salad cream",
      "Zoe garlic paste"
    ],
    "Beverages": [],
    "Snacks": [
      "Almonds",
      "Dates"
    ],
    "Frozen": [],
    "Canned": [],
    "Other": [
      "Savory biscuits",
      "Sunflower seeds"
    ]
  }
}

--- backend/container/fridge_d1ea98cc4b729f52/recipes.json ---
{
  "items": [
    {
      "name": "Creamy Bell Pepper Wraps",
      "total_ingredients": [
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "Mixed bell peppers",
        "Tortillas",
        "Mozzarella cheese ball",
        "Mint",
        "Arugula"
      ],
      "available_ingredients": [
        "Philadelphia cream cheese",
        "Land O'Lakes butter",
        "Mixed bell peppers",
        "Tortillas",
        "Mozzarella cheese ball",
        "Mint",
        "Arugula"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Melt the Philadelphia cream cheese with a touch of Land O'Lakes butter in a pan.",
        "Step 2: Dice the mixed bell peppers and saut\u00e9 them until soft.",
        "Step 3: Spread the cream cheese mixture onto the tortillas.",
        "Step 4: Layer the saut\u00e9ed bell peppers, shredded mozzarella cheese, fresh mint leaves, and arugula.",
        "Step 5: Roll the tortilla tightly and slice into wrap-sized pieces."
      ],
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Sesame Olive Salad",
      "total_ingredients": [
        "Hellmann's mayonnaise",
        "Roland kalamata olive paste",
        "Yokki sesame paste",
        "Cilantro",
        "Arugula",
        "Red cabbage",
        "Sunflower seeds"
      ],
      "available_ingredients": [
        "Hellmann's mayonnaise",
        "Roland kalamata olive paste",
        "Yokki sesame paste",
        "Cilantro",
        "Arugula",
        "Red cabbage",
        "Sunflower seeds"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: In a bowl, mix Hellmann's mayonnaise with Roland kalamata olive paste and Yokki sesame paste.",
        "Step 2: Finely chop cilantro, arugula, and red cabbage.",
        "Step 3: Combine chopped greens and cabbage with the mayonnaise mixture.",
        "Step 4: Sprinkle sunflower seeds on top and toss everything to coat evenly."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Buttered Apple and Pear Crumble",
      "total_ingredients": [
        "Land O'Lakes butter",
        "Apples",
        "Pears",
        "Maple Grove Farms syrup",
        "Savory biscuits",
        "Almonds",
        "Eggs"
      ],
      "available_ingredients": [
        "Land O'Lakes butter",
        "Apples",
        "Pears",
        "Maple Grove Farms syrup",
        "Savory biscuits",
        "Almonds"
      ],
      "missing_ingredients": [
        "Eggs"
      ],
      "completeness_score": 86,
      "instructions": [
        "Step 1: Preheat the oven to 375\u00b0F (190\u00b0C).",
        "Step 2: Slice apples and pears, and toss with a drizzle of Maple Grove Farms syrup.",
        "Step 3: Crush savory biscuits and almonds, and mix with melted Land O'Lakes butter.",
        "Step 4: Layer the fruit mixture in a baking dish and top with the biscuit-almond crumble.",
        "Step 5: Bake for 30 minutes or until golden brown."
      ],
      "cooking_time": "40 minutes",
      "difficulty": "Medium"
    },
    {
      "name": "Spicy Mint Egg Omelette",
      "total_ingredients": [
        "Eggs",
        "Annie's mustard",
        "Mint",
        "Cilantro",
        "Mixed bell peppers",
        "Mozzarella cheese ball",
        "Zoe garlic paste"
      ],
      "available_ingredients": [
        "Eggs",
        "Annie's mustard",
        "Mint",
        "Cilantro",
        "Mixed bell peppers",
        "Mozzarella cheese ball",
        "Zoe garlic paste"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Beat eggs in a bowl with Annie's mustard and Zoe garlic paste.",
        "Step 2: Finely chop mint leaves, cilantro, and mixed bell peppers.",
        "Step 3: Stir chopped veggies into the egg mixture.",
        "Step 4: Heat a pan and pour in the egg mixture.",
        "Step 5: Sprinkle shredded mozzarella cheese over the omelette.",
        "Step 6: Cook until set, then fold and serve."
      ],
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "name": "Fruit & Nut Salad with Creamy Dressing",
      "total_ingredients": [
        "Bananas",
        "Pears",
        "Apples",
        "Hellmann's mayonnaise",
        "Colman's mustard",
        "Sunflower seeds",
        "Dates",
        "Almonds"
      ],
      "available_ingredients": [
        "Bananas",
        "Pears",
        "Apples",
        "Hellmann's mayonnaise",
        "Colman's mustard",
        "Sunflower seeds",
        "Dates",
        "Almonds"
      ],
      "missing_ingredients": [],
      "completeness_score": 100,
      "instructions": [
        "Step 1: Slice bananas, pears, and apples into bite-sized pieces.",
        "Step 2: In a bowl, mix Hellmann's mayonnaise with a small amount of Colman's mustard.",
        "Step 3: Combine the fruits with sunflower seeds, chopped dates, and almonds.",
        "Step 4: Drizzle the creamy dressing over the fruit salad and mix gently."
      ],
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "analysis": [
    {
      "recipe_name": "Creamy Bell Pepper Wraps",
      "completeness": 100,
      "available_count": 7,
      "missing_count": 0,
      "total_ingredients": 7,
      "cooking_time": "20 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Sesame Olive Salad",
      "completeness": 100,
      "available_count": 7,
      "missing_count": 0,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Buttered Apple and Pear Crumble",
      "completeness": 86,
      "available_count": 6,
      "missing_count": 1,
      "total_ingredients": 7,
      "cooking_time": "40 minutes",
      "difficulty": "Medium"
    },
    {
      "recipe_name": "Spicy Mint Egg Omelette",
      "completeness": 100,
      "available_count": 7,
      "missing_count": 0,
      "total_ingredients": 7,
      "cooking_time": "15 minutes",
      "difficulty": "Easy"
    },
    {
      "recipe_name": "Fruit & Nut Salad with Creamy Dressing",
      "completeness": 100,
      "available_count": 8,
      "missing_count": 0,
      "total_ingredients": 8,
      "cooking_time": "10 minutes",
      "difficulty": "Easy"
    }
  ],
  "ingredient_count": 28
}

--- backend/main.py ---
import argparse
from flask import Flask

# Import services and config
from config import Config
from services.azure_client import AzureClientService
from services.vision_service import VisionService
from services.recipe_service import RecipeService

from flask_cors import CORS

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # This enables CORS for all routes

# Global services
config = None
vision_service = None
recipe_service = None

def setup_services():
    """
    Set up the application services
    """
    global config, vision_service, recipe_service
    
    # Initialize configuration
    config = Config()
    
    # Initialize services
    azure_client = AzureClientService(config)
    vision_service = VisionService(azure_client)
    recipe_service = RecipeService(azure_client)
    
    # Import routes after Flask app is initialized
    from api.routes import app as routes_blueprint
    
    # Register blueprint with the main Flask app
    app.register_blueprint(routes_blueprint)
    
    # Provide services to routes module
    import api.routes as routes
    routes.vision_service = vision_service
    routes.recipe_service = recipe_service
    routes.config = config

def main():
    """Main entry point for the application"""
    parser = argparse.ArgumentParser(description="Kitchen Copilot API Server")
    parser.add_argument("--host", default="127.0.0.1", help="Host for API server")
    parser.add_argument("--port", type=int, default=5000, help="Port for API server")
    
    args = parser.parse_args()
    
    # Setup services
    setup_services()
    
    print(f"Starting Kitchen Copilot API server on {args.host}:{args.port}")
    app.run(host=args.host, port=args.port, debug=False)

if __name__ == "__main__":
    main()

--- backend/models/ingredients.py ---
"""
Ingredients Models - Data models for ingredients
"""

from dataclasses import dataclass
from typing import Dict, List

@dataclass
class IngredientsResult:
    """Data class representing ingredients analysis result"""
    ingredients: Dict[str, List[str]]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create an IngredientsResult instance from a dictionary
        
        Args:
            data: Dictionary with ingredients by category
            
        Returns:
            IngredientsResult instance
        """
        if "ingredients" not in data:
            raise ValueError("Invalid ingredients data: 'ingredients' key not found")
        return cls(ingredients=data["ingredients"])
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with ingredients data
        """
        return {
            "ingredients": self.ingredients
        }
    
    def get_all_ingredients(self):
        """
        Get a flattened list of all ingredients
        
        Returns:
            List of all ingredients across categories
        """
        result = []
        for category_items in self.ingredients.values():
            result.extend(category_items)
        return result

--- backend/models/recipes.py ---
"""
Recipe Models - Data models for recipes
"""

from dataclasses import dataclass
from typing import List

@dataclass
class Recipe:
    """Data class representing a single recipe"""
    name: str
    total_ingredients: List[str]
    available_ingredients: List[str]
    missing_ingredients: List[str]
    completeness_score: float
    instructions: List[str]
    cooking_time: str
    difficulty: str
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a Recipe instance from a dictionary
        
        Args:
            data: Dictionary with recipe data
            
        Returns:
            Recipe instance
        """
        return cls(
            name=data["name"],
            total_ingredients=data["total_ingredients"],
            available_ingredients=data["available_ingredients"],
            missing_ingredients=data["missing_ingredients"],
            completeness_score=data["completeness_score"],
            instructions=data["instructions"],
            cooking_time=data["cooking_time"],
            difficulty=data["difficulty"]
        )
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipe data
        """
        return {
            "name": self.name,
            "total_ingredients": self.total_ingredients,
            "available_ingredients": self.available_ingredients,
            "missing_ingredients": self.missing_ingredients,
            "completeness_score": self.completeness_score,
            "instructions": self.instructions,
            "cooking_time": self.cooking_time,
            "difficulty": self.difficulty
        }

@dataclass
class RecipeCollection:
    """Data class representing a collection of recipes"""
    recipes: List[Recipe]
    
    @classmethod
    def from_dict(cls, data):
        """
        Create a RecipeCollection instance from a dictionary
        
        Args:
            data: Dictionary with recipes data
            
        Returns:
            RecipeCollection instance
        """
        if "recipes" not in data:
            raise ValueError("Invalid recipes data: 'recipes' key not found")
            
        recipes = [Recipe.from_dict(r) for r in data["recipes"]]
        return cls(recipes=recipes)
    
    def to_dict(self):
        """
        Convert to dictionary representation
        
        Returns:
            Dictionary with recipes data
        """
        return {
            "recipes": [r.to_dict() for r in self.recipes]
        }

--- backend/prompts/recipe_prompt.py ---
"""
Recipe Generation Prompt - System prompt for the recipe generation service
"""

def get_recipe_system_prompt():
    """
    Return the system prompt for recipe generation
    
    Returns:
        String containing the system prompt
    """
    return """You are a creative chef who specializes in creating recipes based on available ingredients.
Your task is to suggest recipes that can be made with the provided ingredients.
For each recipe, you will:
1. Generate the recipe name
2. List all required ingredients (both those provided and those missing)
3. Provide detailed cooking instructions
4. Rate what percentage of necessary ingredients are available

Return your suggestions as a JSON object with the following structure:
{
  "recipes": [
    {
      "name": "Recipe Name",
      "total_ingredients": [list of all ingredients needed],
      "available_ingredients": [list of ingredients from user's inventory],
      "missing_ingredients": [list of ingredients not in user's inventory],
      "completeness_score": 85,  // percentage of available ingredients
      "instructions": ["Step 1...", "Step 2...", ...],
      "cooking_time": "30 minutes",
      "difficulty": "Easy/Medium/Hard"
    },
    ...
  ]
}
"""

--- backend/prompts/vision_prompt.py ---
"""
Vision Analysis Prompt - System prompt for the vision analysis service
"""

def get_vision_system_prompt():
    """
    Return the system prompt for fridge image analysis
    
    Returns:
        String containing the system prompt
    """
    return """You are a helpful kitchen assistant with excellent vision capabilities.
Your task is to:
1. Identify ALL food ingredients and items visible in this refrigerator/kitchen image
2. List as many ingredients as you can possibly identify
3. Be specific about each item (e.g., "fresh spinach leaves" instead of just "vegetables")
4. Organize ingredients into ONLY the following categories:
   - Dairy (milk, cheese, yogurt, butter, etc.)
   - Produce (fruits, vegetables, herbs, etc.)
   - Proteins (meat, poultry, fish, tofu, etc.)
   - Grains (bread, rice, pasta, cereals, etc.)
   - Condiments (sauces, dressings, spreads, etc.)
   - Beverages (drinks, juices, etc.)
   - Snacks (chips, cookies, nuts, etc.)
   - Frozen (ice cream, frozen meals, etc.)
   - Canned (canned vegetables, beans, soups, etc.)
   - Other (any items that don't fit the above categories)
5. Return your analysis as a JSON object with:
   - A key "ingredients" containing an object with these specific category names as keys
   - Each category should contain an array of specific ingredients
   - If a category has no items, include it with an empty array
6. Be thorough and try to identify even partially visible items
7. IMPORTANT: Use ONLY the specified categories above, do not create your own categories"""

--- backend/services/azure_client.py ---
"""
Azure Client Service - Handles Azure OpenAI API client initialization
"""

from openai import AzureOpenAI

class AzureClientService:
    """Service for interacting with Azure OpenAI API"""
    
    def __init__(self, config):
        """
        Initialize the Azure OpenAI client
        
        Args:
            config: Configuration object containing Azure OpenAI credentials
        """
        azure_config = config.get_azure_config()
        self.client = AzureOpenAI(
            api_key=azure_config["api_key"],
            api_version=azure_config["api_version"],
            azure_endpoint=azure_config["endpoint"]
        )
        self.model_name = azure_config["model_name"]
        
    def get_client(self):
        """Get the initialized Azure OpenAI client"""
        return self.client
        
    def get_model_name(self):
        """Get the model name to use for API calls"""
        return self.model_name

--- backend/services/recipe_service.py ---
"""
Recipe Service - Service for generating recipe suggestions based on ingredients
"""

import json
import os
import pandas as pd
from prompts.recipe_prompt import get_recipe_system_prompt

class RecipeService:
    """Service for generating recipes based on available ingredients"""
    
    def __init__(self, azure_client):
        """
        Initialize the Recipe Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def load_ingredients(self, json_path):
        """
        Load and flatten ingredients from JSON file
        
        Args:
            json_path: Path to the JSON file with ingredients
            
        Returns:
            List of ingredient strings
        """
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)
            
            # Extract ingredients from the full response
            # Check if it's a full API response or just the ingredients
            if 'result' in data and 'ingredients' in data['result']:
                ingredients_data = data['result']['ingredients']
            elif 'ingredients' in data:
                ingredients_data = data['ingredients']
            else:
                raise ValueError("Could not find ingredients in the JSON file")
            
            # Flatten the ingredients list
            all_ingredients = []
            for category, items in ingredients_data.items():
                all_ingredients.extend(items)
            
            return all_ingredients
        except Exception as e:
            raise Exception(f"Error loading ingredients: {str(e)}")
    
    def generate_recipes(self, ingredients, num_recipes=5):
        """
        Generate recipe suggestions using Azure OpenAI API
        
        Args:
            ingredients: List of available ingredients
            num_recipes: Number of recipes to generate
            
        Returns:
            Dictionary containing recipe suggestions
        """
        ingredients_str = ", ".join(ingredients)
        user_prompt = f"""Here are the ingredients I have available: {ingredients_str}. 
Please suggest {num_recipes} diverse recipes that I could make with these ingredients. 
Include some recipes that use most of what I have, and some creative options that might 
require a few additional ingredients. Focus on wholesome, flavorful dishes."""

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_recipe_system_prompt()},
                    {"role": "user", "content": user_prompt}
                ],
                max_tokens=4000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error generating recipes: {str(e)}")
    
    def save_recipes(self, recipes_data, output_path):
        """
        Save recipes to a JSON file
        
        Args:
            recipes_data: Recipe data (complete response)
            output_path: Path to save the output file
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as f:
            json.dump(recipes_data, f, indent=2)
        return output_path
    
    def get_recipes_analysis(self, recipes_data):
        """
        Create a DataFrame with recipe analysis
        
        Args:
            recipes_data: Recipe data from generate_recipes
            
        Returns:
            DataFrame with recipe analysis or None if no recipes
        """
        # Check if recipes_data is already the full response or just the recipes
        if isinstance(recipes_data, dict) and "recipes" in recipes_data:
            recipes_list = recipes_data["recipes"]
        elif isinstance(recipes_data, dict) and "items" in recipes_data:
            recipes_list = recipes_data["items"]
        else:
            recipes_list = []
        
        if not recipes_list:
            return None
        
        return pd.DataFrame([{
            "recipe_name": r["name"],
            "completeness": r["completeness_score"],
            "available_count": len(r["available_ingredients"]),
            "missing_count": len(r["missing_ingredients"]),
            "total_ingredients": len(r["total_ingredients"]),
            "cooking_time": r["cooking_time"],
            "difficulty": r["difficulty"]
        } for r in recipes_list])

--- backend/services/vision_service.py ---
"""
Vision Service - Service for analyzing fridge/food images
"""

import json
import os
from utils.image_utils import encode_image
from prompts.vision_prompt import get_vision_system_prompt

class VisionService:
    """Service for analyzing food/fridge images using Azure OpenAI Vision API"""
    
    def __init__(self, azure_client):
        """
        Initialize the Vision Service
        
        Args:
            azure_client: An initialized AzureClientService object
        """
        self.client = azure_client.get_client()
        self.model_name = azure_client.get_model_name()
    
    def analyze_image(self, image_path):
        """
        Analyze the image using Azure OpenAI Vision API
        
        Args:
            image_path: Path to the input image
            
        Returns:
            Dictionary containing the analysis results
            
        Raises:
            Exception: If the API call fails or parsing fails
        """
        try:
            base64_image = encode_image(image_path)
            
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=[
                    {"role": "system", "content": get_vision_system_prompt()},
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": "Please identify all the food ingredients and items in this refrigerator image. List as many as you can see and be specific about each item."},
                            {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{base64_image}"}}
                        ]
                    }
                ],
                max_tokens=2000,
                response_format={"type": "json_object"}
            )
            
            return json.loads(response.choices[0].message.content)
        except Exception as e:
            raise Exception(f"Error analyzing image: {str(e)}")
    
    def save_analysis(self, analysis_data, output_path):
        """
        Save the analysis result to a JSON file
        
        Args:
            analysis_data: The complete analysis data to save
            output_path: Path to save the JSON output
            
        Returns:
            Path to the saved file
        """
        os.makedirs(os.path.dirname(output_path), exist_ok=True)
        with open(output_path, "w") as json_file:
            json.dump(analysis_data, json_file, indent=2)
        
        return output_path
    
    def get_ingredients_summary(self, analysis_result):
        """
        Generate a summary of the ingredients from the analysis
        
        Args:
            analysis_result: The analysis result from analyze_image
            
        Returns:
            Dictionary with summary statistics
        """
        if "ingredients" not in analysis_result:
            return {
                "total_count": 0,
                "categories": 0,
                "by_category": {}
            }
        
        categories = analysis_result["ingredients"]
        by_category = {category: len(items) for category, items in categories.items()}
        total_count = sum(by_category.values())
        
        return {
            "total_count": total_count,
            "categories": len(categories),
            "by_category": by_category
        }

--- backend/utils/image_utils.py ---
"""
Image Utilities - Functions for handling images
"""

import base64
import os

def encode_image(image_path):
    """
    Encode an image to base64 string
    
    Args:
        image_path: Path to the image file
        
    Returns:
        Base64 encoded string of the image
    
    Raises:
        FileNotFoundError: If the image file doesn't exist
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found at path: {image_path}")
        
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

--- requirements.txt ---
numpy==1.26.3
torch 
ultralytics 
opencv-python 
pillow
openai
python-dotenv
uvicorn
fastapi
pydantic
pandas
python-multipart
flask
werkzeug
flask-cors

